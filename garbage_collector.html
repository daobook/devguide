<!doctype html>
<html class="no-js" lang="zh_CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="Updating standard library extension modules" href="extensions.html" /><link rel="prev" title="Design of CPython’s Compiler" href="compiler.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.01.02"/>
        <title>Design of CPython’s Garbage Collector - Python Developer&#39;s Guide</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=df49af52631e7917044a9c21a57f7b83170a6dd0" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=fade93df149f7c5fedb3ff897f799dc7d283b420" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Python Developer's Guide </div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/python-logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Python Developer's Guide </span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=搜索 name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Where to Get Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="pullrequest.html">Lifecycle of a Pull Request</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtests.html">Running &amp; Writing Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverage.html">Increase Test Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="docquality.html">Helping with Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documenting.html">Documenting Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="silencewarnings.html">Silence Warnings From the Test Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="fixingissues.html">Fixing “easy” Issues (and Beyond)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tracker.html">Issue Tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="triaging.html">Triaging an Issue</a></li>
<li class="toctree-l1"><a class="reference internal" href="communication.html">Following Python’s Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="porting.html">Porting Python to a new platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="coredev.html">How to Become a Core Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developer Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="committing.html">Accepting Pull Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="devcycle.html">Development Cycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildbots.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="stdlibchanges.html">Adding to the Stdlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="langchanges.html">Changing the Python Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="experts.html">Experts Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="gdb.html">gdb Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="exploring.html">Exploring CPython’s Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">Changing CPython’s Grammar</a></li>
<li class="toctree-l1"><a class="reference internal" href="parser.html">Guide to CPython’s Parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiler.html">Design of CPython’s Compiler</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Design of CPython’s Garbage Collector</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">Updating standard library extension modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">Changing Python’s C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverity.html">Coverity Scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="clang.html">Dynamic Analysis with Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildworker.html">Running a buildbot worker</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivations.html">Core Developer Motivations and Affiliations</a></li>
<li class="toctree-l1"><a class="reference internal" href="gitbootcamp.html">Git Bootcamp and Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix: Topics</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="design-of-cpython-s-garbage-collector">
<span id="gc"></span><h1>Design of CPython’s Garbage Collector<a class="headerlink" href="#design-of-cpython-s-garbage-collector" title="永久链接至标题">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Pablo Galindo Salgado</p>
</dd>
</dl>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>The main garbage collection algorithm used by CPython is reference counting. The basic idea is
that CPython counts how many different places there are that have a reference to an
object. Such a place could be another object, or a global (or static) C variable, or
a local variable in some C function. When an object’s reference count becomes zero,
the object is deallocated. If it contains references to other objects, their
reference counts are decremented. Those other objects may be deallocated in turn, if
this decrement makes their reference count become zero, and so on. The reference
count field can be examined using the <code class="docutils literal notranslate"><span class="pre">sys.getrefcount</span></code> function (notice that the
value returned by this function is always 1 more as the function also has a reference
to the object when called):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The main problem with the reference counting scheme is that it does not handle reference
cycles. For instance, consider this code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">container</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">container</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">container</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">container</span></code> holds a reference to itself, so even when we remove
our reference to it (the variable “container”) the reference count never falls to 0
because it still has its own internal reference. Therefore it would never be
cleaned just by simple reference counting. For this reason some additional machinery
is needed to clean these reference cycles between objects once they become
unreachable. This is the cyclic garbage collector, usually called just Garbage
Collector (GC), even though reference counting is also a form of garbage collection.</p>
</section>
<section id="memory-layout-and-object-structure">
<h2>Memory layout and object structure<a class="headerlink" href="#memory-layout-and-object-structure" title="永久链接至标题">¶</a></h2>
<p>Normally the C structure supporting a regular Python object looks as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>object -----&gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \
              |                    ob_refcnt                  | |
              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | PyObject_HEAD
              |                    *ob_type                   | |
              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /
              |                      ...                      |
</pre></div>
</div>
<p>In order to support the garbage collector, the memory layout of objects is altered
to accommodate extra information <strong>before</strong> the normal layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \
              |                    *_gc_next                  | |
              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | PyGC_Head
              |                    *_gc_prev                  | |
object -----&gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /
              |                    ob_refcnt                  | \
              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | PyObject_HEAD
              |                    *ob_type                   | |
              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /
              |                      ...                      |
</pre></div>
</div>
<p>In this way the object can be treated as a normal python object and when the extra
information associated to the GC is needed the previous fields can be accessed by a
simple type cast from the original object: <code class="code docutils literal notranslate"><span class="pre">((PyGC_Head</span> <span class="pre">*)(the_object)-1)</span></code>.</p>
<p>As is explained later in the <a class="reference internal" href="#optimization-reusing-fields-to-save-memory">Optimization: reusing fields to save memory</a> section,
these two extra fields are normally used to keep doubly linked lists of all the
objects tracked by the garbage collector (these lists are the GC generations, more on
that in the <a class="reference internal" href="#optimization-generations">Optimization: generations</a> section), but they are also
reused to fulfill other purposes when the full doubly linked list structure is not
needed as a memory optimization.</p>
<p>Doubly linked lists are used because they efficiently support most frequently required operations.  In
general, the collection of all objects tracked by GC are partitioned into disjoint sets, each in its own
doubly linked list.  Between collections, objects are partitioned into “generations”, reflecting how
often they’ve survived collection attempts.  During collections, the generation(s) being collected
are further partitioned into, e.g., sets of reachable and unreachable objects.  Doubly linked lists
support moving an object from one partition to another, adding a new object,  removing an object
entirely (objects tracked by GC are most often reclaimed by the refcounting system when GC
isn’t running at all!), and merging partitions, all with a small constant number of pointer updates.
With care, they also support iterating over a partition while objects are being added to - and
removed from - it, which is frequently required while GC is running.</p>
<p>Specific APIs are offered to allocate, deallocate, initialize, track, and untrack
objects with GC support. These APIs can be found in the <a class="reference external" href="https://docs.python.org/3.8/c-api/gcsupport.html">Garbage Collector C API
documentation</a>.</p>
<p>Apart from this object structure, the type object for objects supporting garbage
collection must include the <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code> in its <code class="docutils literal notranslate"><span class="pre">tp_flags</span></code> slot and
provide an implementation of the <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> handler. Unless it can be proven
that the objects cannot form reference cycles with only objects of its type or unless
the type is immutable, a <code class="docutils literal notranslate"><span class="pre">tp_clear</span></code> implementation must also be provided.</p>
</section>
<section id="identifying-reference-cycles">
<h2>Identifying reference cycles<a class="headerlink" href="#identifying-reference-cycles" title="永久链接至标题">¶</a></h2>
<p>The algorithm that CPython uses to detect those reference cycles is
implemented in the <code class="docutils literal notranslate"><span class="pre">gc</span></code> module. The garbage collector <strong>only focuses</strong>
on cleaning container objects (i.e. objects that can contain a reference
to one or more objects). These can be arrays, dictionaries, lists, custom
class instances, classes in extension modules, etc. One could think that
cycles are uncommon but the truth is that many internal references needed by
the interpreter create cycles everywhere. Some notable examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Exceptions contain traceback objects that contain a list of frames that
contain the exception itself.</p></li>
<li><p>Module-level functions reference the module’s dict (which is needed to resolve globals),
which in turn contains entries for the module-level functions.</p></li>
<li><p>Instances have references to their class which itself references its module, and the module
contains references to everything that is inside (and maybe other modules)
and this can lead back to the original instance.</p></li>
<li><p>When representing data structures like graphs, it is very typical for them to
have internal links to themselves.</p></li>
</ul>
</div></blockquote>
<p>To correctly dispose of these objects once they become unreachable, they need to be
identified first.  Inside the function that identifies cycles, two double-linked
lists are maintained: one list contains all objects to be scanned, and the other will
contain all objects “tentatively” unreachable.</p>
<p>To understand how the algorithm works, Let’s take the case of a circular linked list
which has one link referenced by a variable <code class="docutils literal notranslate"><span class="pre">A</span></code>, and one self-referencing object which
is completely unreachable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Link</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_link</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>       <span class="bp">self</span><span class="o">.</span><span class="n">next_link</span> <span class="o">=</span> <span class="n">next_link</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">link_3</span> <span class="o">=</span> <span class="n">Link</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link_2</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="n">link_3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link_1</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="n">link_2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link_3</span><span class="o">.</span><span class="n">next_link</span> <span class="o">=</span> <span class="n">link_1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">link_1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">link_1</span><span class="p">,</span> <span class="n">link_2</span><span class="p">,</span> <span class="n">link_3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">link_4</span> <span class="o">=</span> <span class="n">Link</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link_4</span><span class="o">.</span><span class="n">next_link</span> <span class="o">=</span> <span class="n">link_4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">link_4</span>

<span class="go"># Collect the unreachable Link object (and its .__dict__ dict).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>When the GC starts, it has all the container objects it wants to scan
on the first linked list. The objective is to move all the unreachable
objects. Since most objects turn out to be reachable, it is much more
efficient to move the unreachable as this involves fewer pointer updates.</p>
<p>Every object that supports garbage collection will have an extra reference
count field initialized to the reference count (<code class="docutils literal notranslate"><span class="pre">gc_ref</span></code> in the figures)
of that object when the algorithm starts. This is because the algorithm needs
to modify the reference count to do the computations and in this way the
interpreter will not modify the real reference count field.</p>
<figure class="align-default">
<img alt="_images/python-cyclic-gc-1-new-page.png" src="_images/python-cyclic-gc-1-new-page.png"/>
</figure>
<p>The GC then iterates over all containers in the first list and decrements by one the
<code class="docutils literal notranslate"><span class="pre">gc_ref</span></code> field of any other object that container is referencing.  Doing
this makes use of the <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> slot in the container class (implemented
using the C API or inherited by a superclass) to know what objects are referenced by
each container. After all the objects have been scanned, only the objects that have
references from outside the “objects to scan” list will have <code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<figure class="align-default">
<img alt="_images/python-cyclic-gc-2-new-page.png" src="_images/python-cyclic-gc-2-new-page.png"/>
</figure>
<p>Notice that having <code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">==</span> <span class="pre">0</span></code> does not imply that the object is unreachable.
This is because another object that is reachable from the outside (<code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>)
can still have references to it. For instance, the <code class="docutils literal notranslate"><span class="pre">link_2</span></code> object in our example
ended having <code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">==</span> <span class="pre">0</span></code> but is referenced still by the <code class="docutils literal notranslate"><span class="pre">link_1</span></code> object that
is reachable from the outside. To obtain the set of objects that are really
unreachable, the garbage collector re-scans the container objects using the
<code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> slot; this time with a different traverse function that marks objects with
<code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">==</span> <span class="pre">0</span></code> as “tentatively unreachable” and then moves them to the
tentatively unreachable list. The following image depicts the state of the lists in a
moment when the GC processed the <code class="docutils literal notranslate"><span class="pre">link_3</span></code> and <code class="docutils literal notranslate"><span class="pre">link_4</span></code> objects but has not
processed <code class="docutils literal notranslate"><span class="pre">link_1</span></code> and <code class="docutils literal notranslate"><span class="pre">link_2</span></code> yet.</p>
<figure class="align-default">
<img alt="_images/python-cyclic-gc-3-new-page.png" src="_images/python-cyclic-gc-3-new-page.png"/>
</figure>
<p>Then the GC scans the next <code class="docutils literal notranslate"><span class="pre">link_1</span></code> object. Because it has <code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">==</span> <span class="pre">1</span></code>,
the gc does not do anything special because it knows it has to be reachable (and is
already in what will become the reachable list):</p>
<figure class="align-default">
<img alt="_images/python-cyclic-gc-4-new-page.png" src="_images/python-cyclic-gc-4-new-page.png"/>
</figure>
<p>When the GC encounters an object which is reachable (<code class="docutils literal notranslate"><span class="pre">gc_refs</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>), it traverses
its references using the <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> slot to find all the objects that are
reachable from it, moving them to the end of the list of reachable objects (where
they started originally) and setting its <code class="docutils literal notranslate"><span class="pre">gc_refs</span></code> field to 1. This is what happens
to <code class="docutils literal notranslate"><span class="pre">link_2</span></code> and <code class="docutils literal notranslate"><span class="pre">link_3</span></code> below as they are reachable from <code class="docutils literal notranslate"><span class="pre">link_1</span></code>.  From the
state in the previous image and after examining the objects referred to by <code class="docutils literal notranslate"><span class="pre">link_1</span></code>
the GC knows that <code class="docutils literal notranslate"><span class="pre">link_3</span></code> is reachable after all, so it is moved back to the
original list and its <code class="docutils literal notranslate"><span class="pre">gc_refs</span></code> field is set to 1 so that if the GC visits it again,
it will know that it’s reachable. To avoid visiting an object twice, the GC marks all
objects that have already been visited once (by unsetting the <code class="docutils literal notranslate"><span class="pre">PREV_MASK_COLLECTING</span></code>
flag) so that if an object that has already been processed is referenced by some other
object, the GC does not process it twice.</p>
<figure class="align-default">
<img alt="_images/python-cyclic-gc-5-new-page.png" src="_images/python-cyclic-gc-5-new-page.png"/>
</figure>
<p>Notice that an object that was marked as “tentatively unreachable” and was later
moved back to the reachable list will be visited again by the garbage collector
as now all the references that that object has need to be processed as well. This
process is really a breadth first search over the object graph. Once all the objects
are scanned, the GC knows that all container objects in the tentatively unreachable
list are really unreachable and can thus be garbage collected.</p>
<p>Pragmatically, it’s important to note that no recursion is required by any of this,
and neither does it in any other way require additional memory proportional to the
number of objects, number of pointers, or the lengths of pointer chains.  Apart from
<code class="docutils literal notranslate"><span class="pre">O(1)</span></code> storage for internal C needs, the objects themselves contain all the storage
the GC algorithms require.</p>
<section id="why-moving-unreachable-objects-is-better">
<h3>Why moving unreachable objects is better<a class="headerlink" href="#why-moving-unreachable-objects-is-better" title="永久链接至标题">¶</a></h3>
<p>It sounds logical to move the unreachable objects under the premise that most objects
are usually reachable, until you think about it: the reason it pays isn’t actually
obvious.</p>
<p>Suppose we create objects A, B, C in that order. They appear in the young generation
in the same order. If B points to A, and C to B, and C is reachable from outside,
then the adjusted refcounts after the first step of the algorithm runs will be 0, 0,
and 1 respectively because the only reachable object from the outside is C.</p>
<p>When the next step of the algorithm finds A, A is moved to the unreachable list. The
same for B when it’s first encountered. Then C is traversed, B is moved <em>back</em> to
the reachable list. B is eventually traversed, and then A is moved back to the reachable
list.</p>
<p>So instead of not moving at all, the reachable objects B and A are each moved twice.
Why is this a win? A straightforward algorithm to move the reachable objects instead
would move A, B, and C once each. The key is that this dance leaves the objects in
order C, B, A - it’s reversed from the original order.  On all <em>subsequent</em> scans,
none of them will move.  Since most objects aren’t in cycles, this can save an
unbounded number of moves across an unbounded number of later collections. The only
time the cost can be higher is the first time the chain is scanned.</p>
</section>
</section>
<section id="destroying-unreachable-objects">
<h2>Destroying unreachable objects<a class="headerlink" href="#destroying-unreachable-objects" title="永久链接至标题">¶</a></h2>
<p>Once the GC knows the list of unreachable objects, a very delicate process starts
with the objective of completely destroying these objects. Roughly, the process
follows these steps in order:</p>
<ol class="arabic simple">
<li><p>Handle and clean weak references (if any). If an object that is in the unreachable
set is going to be destroyed and has weak references with callbacks, these
callbacks need to be honored. This process is <strong>very</strong> delicate as any error can
cause objects that will be in an inconsistent state to be resurrected or reached
by some Python functions invoked from the callbacks. In addition, weak references
that also are part of the unreachable set (the object and its weak reference
are in cycles that are unreachable) need to be cleaned
immediately, without executing the callback. Otherwise it will be triggered later,
when the <code class="docutils literal notranslate"><span class="pre">tp_clear</span></code> slot is called, causing havoc. Ignoring the weak reference’s
callback is fine because both the object and the weakref are going away, so it’s
legitimate to say the weak reference is going away first.</p></li>
<li><p>If an object has legacy finalizers (<code class="docutils literal notranslate"><span class="pre">tp_del</span></code> slot) move them to the
<code class="docutils literal notranslate"><span class="pre">gc.garbage</span></code> list.</p></li>
<li><p>Call the finalizers (<code class="docutils literal notranslate"><span class="pre">tp_finalize</span></code> slot) and mark the objects as already
finalized to avoid calling them twice if they resurrect or if other finalizers
have removed the object first.</p></li>
<li><p>Deal with resurrected objects. If some objects have been resurrected, the GC
finds the new subset of objects that are still unreachable by running the cycle
detection algorithm again and continues with them.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">tp_clear</span></code> slot of every object so all internal links are broken and
the reference counts fall to 0, triggering the destruction of all unreachable
objects.</p></li>
</ol>
</section>
<section id="optimization-generations">
<h2>Optimization: generations<a class="headerlink" href="#optimization-generations" title="永久链接至标题">¶</a></h2>
<p>In order to limit the time each garbage collection takes, the GC uses a popular
optimization: generations. The main idea behind this concept is the assumption that
most objects have a very short lifespan and can thus be collected shortly after their
creation. This has proven to be very close to the reality of many Python programs as
many temporary objects are created and destroyed very fast. The older an object is
the less likely it is that it will become unreachable.</p>
<p>To take advantage of this fact, all container objects are segregated into
three spaces/generations. Every new
object starts in the first generation (generation 0). The previous algorithm is
executed only over the objects of a particular generation and if an object
survives a collection of its generation it will be moved to the next one
(generation 1), where it will be surveyed for collection less often. If
the same object survives another GC round in this new generation (generation 1)
it will be moved to the last generation (generation 2) where it will be
surveyed the least often.</p>
<p>Generations are collected when the number of objects that they contain reaches some
predefined threshold, which is unique for each generation and is lower the older
the generations are. These thresholds can be examined using the  <code class="docutils literal notranslate"><span class="pre">gc.get_threshold</span></code>
function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">get_threshold</span><span class="p">()</span>
<span class="go">(700, 10, 10)</span>
</pre></div>
</div>
<p>The content of these generations can be examined using the
<code class="docutils literal notranslate"><span class="pre">gc.get_objects(generation=NUM)</span></code> function and collections can be triggered
specifically in a generation by calling <code class="docutils literal notranslate"><span class="pre">gc.collect(generation=NUM)</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyObj</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>

<span class="go"># Move everything to the last generation so it's easier to inspect</span>
<span class="go"># the younger generations.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">0</span>

<span class="go"># Create a reference cycle.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyObj</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">self</span> <span class="o">=</span> <span class="n">x</span>

<span class="go"># Initially the object is in the youngest generation.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">get_objects</span><span class="p">(</span><span class="n">generation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[..., &lt;__main__.MyObj object at 0x7fbcc12a3400&gt;, ...]</span>

<span class="go"># After a collection of the youngest generation the object</span>
<span class="go"># moves to the next generation.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">generation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">get_objects</span><span class="p">(</span><span class="n">generation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">get_objects</span><span class="p">(</span><span class="n">generation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[..., &lt;__main__.MyObj object at 0x7fbcc12a3400&gt;, ...]</span>
</pre></div>
</div>
<section id="collecting-the-oldest-generation">
<h3>Collecting the oldest generation<a class="headerlink" href="#collecting-the-oldest-generation" title="永久链接至标题">¶</a></h3>
<p>In addition to the various configurable thresholds, the GC only triggers a full
collection of the oldest generation if the ratio <code class="docutils literal notranslate"><span class="pre">long_lived_pending</span> <span class="pre">/</span> <span class="pre">long_lived_total</span></code>
is above a given value (hardwired to 25%). The reason is that, while “non-full”
collections (i.e., collections of the young and middle generations) will always
examine roughly the same number of objects (determined by the aforementioned
thresholds) the cost of a full collection is proportional to the total
number of long-lived objects, which is virtually unbounded.  Indeed, it has
been remarked that doing a full collection every &lt;constant number&gt; of object
creations entails a dramatic performance degradation in workloads which consist
of creating and storing lots of long-lived objects (e.g. building a large list
of GC-tracked objects would show quadratic performance, instead of linear as
expected). Using the above ratio, instead, yields amortized linear performance
in the total number of objects (the effect of which can be summarized thusly:
“each full garbage collection is more and more costly as the number of objects
grows, but we do fewer and fewer of them”).</p>
</section>
</section>
<section id="optimization-reusing-fields-to-save-memory">
<h2>Optimization: reusing fields to save memory<a class="headerlink" href="#optimization-reusing-fields-to-save-memory" title="永久链接至标题">¶</a></h2>
<p>In order to save memory, the two linked list pointers in every object with GC
support are reused for several purposes. This is a common optimization known
as “fat pointers” or “tagged pointers”: pointers that carry additional data,
“folded” into the pointer, meaning stored inline in the data representing the
address, taking advantage of certain properties of memory addressing. This is
possible as most architectures align certain types of data
to the size of the data, often a word or multiple thereof. This discrepancy
leaves a few of the least significant bits of the pointer unused, which can be
used for tags or to keep other information – most often as a bit field (each
bit a separate tag) – as long as code that uses the pointer masks out these
bits before accessing memory.  E.g., on a 32-bit architecture (for both
addresses and word size), a word is 32 bits = 4 bytes, so word-aligned
addresses are always a multiple of 4, hence end in <code class="docutils literal notranslate"><span class="pre">00</span></code>, leaving the last 2 bits
available; while on a 64-bit architecture, a word is 64 bits = 8 bytes, so
word-aligned addresses end in <code class="docutils literal notranslate"><span class="pre">000</span></code>, leaving the last 3 bits available.</p>
<p>The CPython GC makes use of two fat pointers that correspond to the extra fields
of <code class="docutils literal notranslate"><span class="pre">PyGC_Head</span></code> discussed in the <a class="reference internal" href="#memory-layout-and-object-structure">Memory layout and object structure</a> section:</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Because the presence of extra information, “tagged” or “fat” pointers cannot be
dereferenced directly and the extra information must be stripped off before
obtaining the real memory address. Special care needs to be taken with
functions that directly manipulate the linked lists, as these functions
normally assume the pointers inside the lists are in a consistent state.</p>
</div>
</div></blockquote>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">_gc_prev</span></code> field is normally used as the “previous” pointer to maintain the
doubly linked list but its lowest two bits are used to keep the flags
<code class="docutils literal notranslate"><span class="pre">PREV_MASK_COLLECTING</span></code> and <code class="docutils literal notranslate"><span class="pre">_PyGC_PREV_MASK_FINALIZED</span></code>. Between collections,
the only flag that can be present is <code class="docutils literal notranslate"><span class="pre">_PyGC_PREV_MASK_FINALIZED</span></code> that indicates
if an object has been already finalized. During collections <code class="docutils literal notranslate"><span class="pre">_gc_prev</span></code> is
temporarily used for storing a copy of the reference count (<code class="docutils literal notranslate"><span class="pre">gc_refs</span></code>), in
addition to two flags, and the GC linked list becomes a singly linked list until
<code class="docutils literal notranslate"><span class="pre">_gc_prev</span></code> is restored.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">_gc_next</span></code> field is used as the “next” pointer to maintain the doubly linked
list but during collection its lowest bit is used to keep the
<code class="docutils literal notranslate"><span class="pre">NEXT_MASK_UNREACHABLE</span></code> flag that indicates if an object is tentatively
unreachable during the cycle detection algorithm.  This is a drawback to using only
doubly linked lists to implement partitions:  while most needed operations are
constant-time, there is no efficient way to determine which partition an object is
currently in.  Instead, when that’s needed, ad hoc tricks (like the
<code class="docutils literal notranslate"><span class="pre">NEXT_MASK_UNREACHABLE</span></code> flag) are employed.</p></li>
</ul>
</section>
<section id="optimization-delay-tracking-containers">
<h2>Optimization: delay tracking containers<a class="headerlink" href="#optimization-delay-tracking-containers" title="永久链接至标题">¶</a></h2>
<p>Certain types of containers cannot participate in a reference cycle, and so do
not need to be tracked by the garbage collector. Untracking these objects
reduces the cost of garbage collection. However, determining which objects may
be untracked is not free, and the costs must be weighed against the benefits
for garbage collection. There are two possible strategies for when to untrack
a container:</p>
<ol class="arabic simple">
<li><p>When the container is created.</p></li>
<li><p>When the container is examined by the garbage collector.</p></li>
</ol>
<p>As a general rule, instances of atomic types aren’t tracked and instances of
non-atomic types (containers, user-defined objects…) are.  However, some
type-specific optimizations can be present in order to suppress the garbage
collector footprint of simple instances. Some examples of native types that
benefit from delayed tracking:</p>
<ul class="simple">
<li><p>Tuples containing only immutable objects (integers, strings etc,
and recursively, tuples of immutable objects) do not need to be tracked. The
interpreter creates a large number of tuples, many of which will not survive
until garbage collection. It is therefore not worthwhile to untrack eligible
tuples at creation time. Instead, all tuples except the empty tuple are tracked
when created. During garbage collection it is determined whether any surviving
tuples can be untracked. A tuple can be untracked if all of its contents are
already not tracked. Tuples are examined for untracking in all garbage collection
cycles. It may take more than one cycle to untrack a tuple.</p></li>
<li><p>Dictionaries containing only immutable objects also do not need to be tracked.
Dictionaries are untracked when created. If a tracked item is inserted into a
dictionary (either as a key or value), the dictionary becomes tracked. During a
full garbage collection (all generations), the collector will untrack any dictionaries
whose contents are not tracked.</p></li>
</ul>
<p>The garbage collector module provides the Python function <code class="docutils literal notranslate"><span class="pre">is_tracked(obj)</span></code>, which returns
the current tracking status of the object. Subsequent garbage collections may change the
tracking status of the object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({})</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">is_tracked</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:</span> <span class="p">[]})</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="extensions.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Updating standard library extension modules</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="compiler.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Design of CPython’s Compiler</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2011-2022, Python Software Foundation |
            最后更新于 1月 29, 2022. |
          Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
          <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
            | <a class="muted-link" href="_sources/garbage_collector.rst.txt"
               rel="nofollow">
              显示源代码
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Design of CPython’s Garbage Collector</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#memory-layout-and-object-structure">Memory layout and object structure</a></li>
<li><a class="reference internal" href="#identifying-reference-cycles">Identifying reference cycles</a><ul>
<li><a class="reference internal" href="#why-moving-unreachable-objects-is-better">Why moving unreachable objects is better</a></li>
</ul>
</li>
<li><a class="reference internal" href="#destroying-unreachable-objects">Destroying unreachable objects</a></li>
<li><a class="reference internal" href="#optimization-generations">Optimization: generations</a><ul>
<li><a class="reference internal" href="#collecting-the-oldest-generation">Collecting the oldest generation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimization-reusing-fields-to-save-memory">Optimization: reusing fields to save memory</a></li>
<li><a class="reference internal" href="#optimization-delay-tracking-containers">Optimization: delay tracking containers</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    </body>
</html>