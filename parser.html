<!doctype html>
<html class="no-js" lang="zh_CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="Design of CPython’s Compiler" href="compiler.html" /><link rel="prev" title="Changing CPython’s Grammar" href="grammar.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.01.02"/>
        <title>Guide to CPython’s Parser - Python Developer&#39;s Guide</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=df49af52631e7917044a9c21a57f7b83170a6dd0" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=fade93df149f7c5fedb3ff897f799dc7d283b420" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Python Developer's Guide </div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/python-logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Python Developer's Guide </span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=搜索 name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Where to Get Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="pullrequest.html">Lifecycle of a Pull Request</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtests.html">Running &amp; Writing Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverage.html">Increase Test Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="docquality.html">Helping with Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documenting.html">Documenting Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="silencewarnings.html">Silence Warnings From the Test Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="fixingissues.html">Fixing “easy” Issues (and Beyond)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tracker.html">Issue Tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="triaging.html">Triaging an Issue</a></li>
<li class="toctree-l1"><a class="reference internal" href="communication.html">Following Python’s Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="porting.html">Porting Python to a new platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="coredev.html">How to Become a Core Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developer Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="committing.html">Accepting Pull Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="devcycle.html">Development Cycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildbots.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="stdlibchanges.html">Adding to the Stdlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="langchanges.html">Changing the Python Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="experts.html">Experts Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="gdb.html">gdb Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="exploring.html">Exploring CPython’s Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">Changing CPython’s Grammar</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Guide to CPython’s Parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiler.html">Design of CPython’s Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="garbage_collector.html">Design of CPython’s Garbage Collector</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">Updating standard library extension modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">Changing Python’s C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverity.html">Coverity Scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="clang.html">Dynamic Analysis with Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildworker.html">Running a buildbot worker</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivations.html">Core Developer Motivations and Affiliations</a></li>
<li class="toctree-l1"><a class="reference internal" href="gitbootcamp.html">Git Bootcamp and Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix: Topics</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="guide-to-cpython-s-parser">
<span id="parser"></span><h1>Guide to CPython’s Parser<a class="headerlink" href="#guide-to-cpython-s-parser" title="永久链接至标题">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Pablo Galindo Salgado</p>
</dd>
</dl>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>The Parser in CPython is currently a <a class="reference external" href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG (Parser Expression Grammar)</a> parser.  The first
version of the parser used to be an <a class="reference external" href="https://en.wikipedia.org/wiki/LL_parser">LL(1)</a> based parser that was one of the
oldest parts of CPython implemented before it was replaced by <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0617"><strong>PEP 617</strong></a>. In
particular, both the current parser and the old LL(1) parser are the output of a
<a class="reference external" href="https://en.wikipedia.org/wiki/Compiler-compiler">parser generator</a>. This
means that the way the parser is written is by feeding a description of the
Grammar of the Python language to a special program (the parser generator) which
outputs the parser. The way the Python language is changed is therefore by
modifying the grammar file and developers rarely need to interact with the
parser generator itself other than use it to generate the parser.</p>
</section>
<section id="how-peg-parsers-work">
<h2>How PEG Parsers Work<a class="headerlink" href="#how-peg-parsers-work" title="永久链接至标题">¶</a></h2>
<p id="id1">A PEG (Parsing Expression Grammar) grammar (like the current one) differs from a
context-free grammar in that the way it is written more closely
reflects how the parser will operate when parsing it. The fundamental technical
difference is that the choice operator is ordered. This means that when writing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule: A | B | C
</pre></div>
</div>
<p>a context-free-grammar parser (like an LL(1) parser) will generate constructions
that given an input string will <em>deduce</em> which alternative (<code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> or <code class="docutils literal notranslate"><span class="pre">C</span></code>)
must be expanded, while a PEG parser will check if the first alternative succeeds
and only if it fails, will it continue with the second or the third one in the
order in which they are written. This makes the choice operator not commutative.</p>
<p>Unlike LL(1) parsers, PEG-based parsers cannot be ambiguous: if a string parses,
it has exactly one valid parse tree. This means that a PEG-based parser cannot
suffer from the ambiguity problems that can arise with LL(1) parsers and with
context-free grammars in general.</p>
<p>PEG parsers are usually constructed as a recursive descent parser in which every
rule in the grammar corresponds to a function in the program implementing the
parser and the parsing expression (the “expansion” or “definition” of the rule)
represents the “code” in said function. Each parsing function conceptually takes
an input string as its argument, and yields one of the following results:</p>
<ul class="simple">
<li><p>A “success” result. This result indicates that the expression can be parsed by
that rule and the function may optionally move forward or consume one or more
characters of the input string supplied to it.</p></li>
<li><p>A “failure” result, in which case no input is consumed.</p></li>
</ul>
<p>Notice that “failure” results do not imply that the program is incorrect, nor do
they necessarily mean that the parsing has failed. Since the choice operator is
ordered, a failure very often merely indicates “try the following option”.  A
direct implementation of a PEG parser as a recursive descent parser will present
exponential time performance in the worst case, because PEG parsers have
infinite lookahead (this means that they can consider an arbitrary number of
tokens before deciding for a rule).  Usually, PEG parsers avoid this exponential
time complexity with a technique called “packrat parsing” <a class="footnote-reference brackets" href="#id11" id="id2">1</a> which not only
loads the entire program in memory before parsing it but also allows the parser
to backtrack arbitrarily. This is made efficient by memoizing the rules already
matched for each position. The cost of the memoization cache is that the parser
will naturally use more memory than a simple LL(1) parser, which normally are
table-based.</p>
<section id="key-ideas">
<h3>Key ideas<a class="headerlink" href="#key-ideas" title="永久链接至标题">¶</a></h3>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>Don’t try to reason about a PEG grammar in the same way you would to with an EBNF
or context free grammar. PEG is optimized to describe <strong>how</strong> input strings will
be parsed, while context-free grammars are optimized to generate strings of the
language they describe (in EBNF, to know if a given string is in the language, you need
to do work to find out as it is not immediately obvious from the grammar).</p>
</div>
<ul class="simple">
<li><p>Alternatives are ordered ( <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code> is not the same as <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">|</span> <span class="pre">A</span></code> ).</p></li>
<li><p>If a rule returns a failure, it doesn’t mean that the parsing has failed,
it just means “try something else”.</p></li>
<li><p>By default PEG parsers run in exponential time, which can be optimized to linear by
using memoization.</p></li>
<li><p>If parsing fails completely (no rule succeeds in parsing all the input text), the
PEG parser doesn’t have a concept of “where the <a class="reference external" href="https://daobook.github.io/cpython/library/exceptions.html#SyntaxError" title="(在 Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> is”.</p></li>
</ul>
</section>
<section id="consequences-or-the-ordered-choice-operator">
<h3>Consequences or the ordered choice operator<a class="headerlink" href="#consequences-or-the-ordered-choice-operator" title="永久链接至标题">¶</a></h3>
<p id="consequences-of-ordered-choice">Although PEG may look like EBNF, its meaning is quite different. The fact
that in PEG parsers alternatives are ordered (which is at the core of how PEG
parsers work) has deep consequences, other than removing ambiguity.</p>
<p>If a rule has two alternatives and the first of them succeeds, the second one is
<strong>not</strong> attempted even if the caller rule fails to parse the rest of the input.
Thus the parser is said to be “eager”. To illustrate this, consider
the following two rules (in these examples, a token is an individual character):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>first_rule:  ( 'a' | 'aa' ) 'a'
second_rule: ('aa' | 'a'  ) 'a'
</pre></div>
</div>
<p>In a regular EBNF grammar, both rules specify the language <code class="docutils literal notranslate"><span class="pre">{aa,</span> <span class="pre">aaa}</span></code> but
in PEG, one of these two rules accepts the string <code class="docutils literal notranslate"><span class="pre">aaa</span></code> but not the string
<code class="docutils literal notranslate"><span class="pre">aa</span></code>. The other does the opposite – it accepts the string <code class="docutils literal notranslate"><span class="pre">aa</span></code>
but not the string <code class="docutils literal notranslate"><span class="pre">aaa</span></code>. The rule <code class="docutils literal notranslate"><span class="pre">('a'|'aa')'a'</span></code> does
not accept <code class="docutils literal notranslate"><span class="pre">aaa</span></code> because <code class="docutils literal notranslate"><span class="pre">'a'|'aa'</span></code> consumes the first <code class="docutils literal notranslate"><span class="pre">a</span></code>, letting the
final <code class="docutils literal notranslate"><span class="pre">a</span></code> in the rule consume the second, and leaving out the third <code class="docutils literal notranslate"><span class="pre">a</span></code>.
As the rule has succeeded, no attempt is ever made to go back and let
<code class="docutils literal notranslate"><span class="pre">'a'|'aa'</span></code> try the second alternative. The expression <code class="docutils literal notranslate"><span class="pre">('aa'|'a')'a'</span></code> does
not accept <code class="docutils literal notranslate"><span class="pre">aa</span></code> because <code class="docutils literal notranslate"><span class="pre">'aa'|'a'</span></code> accepts all of <code class="docutils literal notranslate"><span class="pre">aa</span></code>, leaving nothing
for the final <code class="docutils literal notranslate"><span class="pre">a</span></code>. Again, the second alternative of <code class="docutils literal notranslate"><span class="pre">'aa'|'a'</span></code> is not
tried.</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>The effects of ordered choice, such as the ones illustrated above, may be hidden by many levels of rules.</p>
</div>
<p>For this reason, writing rules where an alternative is contained in the next one is in almost all cases a mistake,
for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_rule:
    | 'if' expression 'then' block
    | 'if' expression 'then' block 'else' block
</pre></div>
</div>
<p>In this example, the second alternative will never be tried because the first one will
succeed first (even if the input string has an <code class="docutils literal notranslate"><span class="pre">'else'</span> <span class="pre">block</span></code> that follows). To correctly
write this rule you can simply alter the order:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_rule:
    | 'if' expression 'then' block 'else' block
    | 'if' expression 'then' block
</pre></div>
</div>
<p>In this case, if the input string doesn’t have an <code class="docutils literal notranslate"><span class="pre">'else'</span> <span class="pre">block</span></code>, the first alternative
will fail and the second will be attempted without said part.</p>
</section>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="永久链接至标题">¶</a></h2>
<p>The grammar consists of a sequence of rules of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: expression
</pre></div>
</div>
<p>Optionally, a type can be included right after the rule name, which
specifies the return type of the C or Python function corresponding to
the rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name[return_type]: expression
</pre></div>
</div>
<p>If the return type is omitted, then a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> is returned in C and an
<code class="docutils literal notranslate"><span class="pre">Any</span></code> in Python.</p>
<section id="grammar-expressions">
<h3>Grammar Expressions<a class="headerlink" href="#grammar-expressions" title="永久链接至标题">¶</a></h3>
<section id="comment">
<h4><code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">comment</span></code><a class="headerlink" href="#comment" title="永久链接至标题">¶</a></h4>
<p>Python-style comments.</p>
</section>
<section id="e1-e2">
<h4><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">e2</span></code><a class="headerlink" href="#e1-e2" title="永久链接至标题">¶</a></h4>
<p>Match <code class="docutils literal notranslate"><span class="pre">e1</span></code>, then match <code class="docutils literal notranslate"><span class="pre">e2</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: first_rule second_rule
</pre></div>
</div>
</section>
<section id="id3">
<h4><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">|</span> <span class="pre">e2</span></code><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>Match <code class="docutils literal notranslate"><span class="pre">e1</span></code> or <code class="docutils literal notranslate"><span class="pre">e2</span></code>.</p>
<p>The first alternative can also appear on the line after the rule name
for formatting purposes. In that case, a | must be used before the
first alternative, like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name[return_type]:
    | first_alt
    | second_alt
</pre></div>
</div>
</section>
<section id="e">
<h4><code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">e</span> <span class="pre">)</span></code><a class="headerlink" href="#e" title="永久链接至标题">¶</a></h4>
<p>Match <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: (e)
</pre></div>
</div>
<p>A slightly more complex and useful example includes using the grouping
operator together with the repeat operators:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: (e1 e2)*
</pre></div>
</div>
</section>
<section id="e-or-e">
<h4><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">e</span> <span class="pre">]</span> <span class="pre">or</span> <span class="pre">e?</span></code><a class="headerlink" href="#e-or-e" title="永久链接至标题">¶</a></h4>
<p>Optionally match <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: [e]
</pre></div>
</div>
<p>A more useful example includes defining that a trailing comma is
optional:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: e (',' e)* [',']
</pre></div>
</div>
</section>
<section id="id4">
<h4><code class="docutils literal notranslate"><span class="pre">e*</span></code><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>Match zero or more occurrences of <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: (e1 e2)*
</pre></div>
</div>
</section>
<section id="id5">
<h4><code class="docutils literal notranslate"><span class="pre">e+</span></code><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>Match one or more occurrences of <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: (e1 e2)+
</pre></div>
</div>
</section>
<section id="s-e">
<h4><code class="docutils literal notranslate"><span class="pre">s.e+</span></code><a class="headerlink" href="#s-e" title="永久链接至标题">¶</a></h4>
<p>Match one or more occurrences of <code class="docutils literal notranslate"><span class="pre">e</span></code>, separated by <code class="docutils literal notranslate"><span class="pre">s</span></code>. The generated parse
tree does not include the separator. This is otherwise identical to
<code class="docutils literal notranslate"><span class="pre">(e</span> <span class="pre">(s</span> <span class="pre">e)*)</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: ','.e+
</pre></div>
</div>
</section>
<section id="id6">
<h4><code class="docutils literal notranslate"><span class="pre">&amp;e</span></code><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p id="peg-positive-lookahead">Succeed if <code class="docutils literal notranslate"><span class="pre">e</span></code> can be parsed, without consuming any input.</p>
</section>
<section id="id7">
<h4><code class="docutils literal notranslate"><span class="pre">!e</span></code><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p id="peg-negative-lookahead">Fail if <code class="docutils literal notranslate"><span class="pre">e</span></code> can be parsed, without consuming any input.</p>
<p>An example taken from the Python grammar specifies that a primary
consists of an atom, which is not followed by a <code class="docutils literal notranslate"><span class="pre">.</span></code> or a <code class="docutils literal notranslate"><span class="pre">(</span></code> or a
<code class="docutils literal notranslate"><span class="pre">[</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>primary: atom !'.' !'(' !'['
</pre></div>
</div>
</section>
<section id="id8">
<h4><code class="docutils literal notranslate"><span class="pre">~</span></code><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>Commit to the current alternative, even if it fails to parse (this is called
the “cut”).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name: '(' ~ some_rule ')' | some_alt
</pre></div>
</div>
<p>In this example, if a left parenthesis is parsed, then the other
alternative won’t be considered, even if some_rule or <code class="docutils literal notranslate"><span class="pre">)</span></code> fail to be
parsed.</p>
</section>
</section>
<section id="left-recursion">
<h3>Left recursion<a class="headerlink" href="#left-recursion" title="永久链接至标题">¶</a></h3>
<p>PEG parsers normally do not support left recursion but CPython’s parser
generator implements a technique similar to the one described in Medeiros et al.
<a class="footnote-reference brackets" href="#id12" id="id9">2</a> but using the memoization cache instead of static variables. This approach
is closer to the one described in Warth et al. <a class="footnote-reference brackets" href="#id13" id="id10">3</a>. This allows us to write not
only simple left-recursive rules but also more complicated rules that involve
indirect left-recursion like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule1: rule2 | 'a'
rule2: rule3 | 'b'
rule3: rule1 | 'c'
</pre></div>
</div>
<p>and “hidden left-recursion” like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule: 'optional'? rule '@' some_other_rule
</pre></div>
</div>
</section>
<section id="variables-in-the-grammar">
<h3>Variables in the Grammar<a class="headerlink" href="#variables-in-the-grammar" title="永久链接至标题">¶</a></h3>
<p>A sub-expression can be named by preceding it with an identifier and an
<code class="docutils literal notranslate"><span class="pre">=</span></code> sign. The name can then be used in the action (see below), like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name[return_type]: '(' a=some_other_rule ')' { a }
</pre></div>
</div>
</section>
<section id="grammar-actions">
<h3>Grammar actions<a class="headerlink" href="#grammar-actions" title="永久链接至标题">¶</a></h3>
<p id="peg-grammar-actions">To avoid the intermediate steps that obscure the relationship between the
grammar and the AST generation the PEG parser allows directly generating AST
nodes for a rule via grammar actions. Grammar actions are language-specific
expressions that are evaluated when a grammar rule is successfully parsed. These
expressions can be written in Python or C depending on the desired output of the
parser generator. This means that if one would want to generate a parser in
Python and another in C, two grammar files should be written, each one with a
different set of actions, keeping everything else apart from said actions
identical in both files. As an example of a grammar with Python actions, the
piece of the parser generator that parses grammar files is bootstrapped from a
meta-grammar file with Python actions that generate the grammar tree as a result
of the parsing.</p>
<p>In the specific case of the PEG grammar for Python, having actions allows
directly describing how the AST is composed in the grammar itself, making it
more clear and maintainable. This AST generation process is supported by the use
of some helper functions that factor out common AST object manipulations and
some other required operations that are not directly related to the grammar.</p>
<p>To indicate these actions each alternative can be followed by the action code
inside curly-braces, which specifies the return value of the alternative:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name[return_type]:
    | first_alt1 first_alt2 { first_alt1 }
    | second_alt1 second_alt2 { second_alt1 }
</pre></div>
</div>
<p>If the action is omitted, a default action is generated:</p>
<ul class="simple">
<li><p>If there’s a single name in the rule, it gets returned.</p></li>
<li><p>If there is more than one name in the rule, a collection with all parsed
expressions gets returned (the type of the collection will be different
in C and Python).</p></li>
</ul>
<p>This default behaviour is primarily made for very simple situations and for
debugging purposes.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>It’s important that the actions don’t mutate any AST nodes that are passed
into them via variables referring to other rules. The reason for mutation
being not allowed is that the AST nodes are cached by memoization and could
potentially be reused in a different context, where the mutation would be
invalid. If an action needs to change an AST node, it should instead make a
new copy of the node and change that.</p>
</div>
<p>The full meta-grammar for the grammars supported by the PEG generator is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start[Grammar]: grammar ENDMARKER { grammar }

grammar[Grammar]:
    | metas rules { Grammar(rules, metas) }
    | rules { Grammar(rules, []) }

metas[MetaList]:
    | meta metas { [meta] + metas }
    | meta { [meta] }

meta[MetaTuple]:
    | "@" NAME NEWLINE { (name.string, None) }
    | "@" a=NAME b=NAME NEWLINE { (a.string, b.string) }
    | "@" NAME STRING NEWLINE { (name.string, literal_eval(string.string)) }

rules[RuleList]:
    | rule rules { [rule] + rules }
    | rule { [rule] }

rule[Rule]:
    | rulename ":" alts NEWLINE INDENT more_alts DEDENT {
            Rule(rulename[0], rulename[1], Rhs(alts.alts + more_alts.alts)) }
    | rulename ":" NEWLINE INDENT more_alts DEDENT { Rule(rulename[0], rulename[1], more_alts) }
    | rulename ":" alts NEWLINE { Rule(rulename[0], rulename[1], alts) }

rulename[RuleName]:
    | NAME '[' type=NAME '*' ']' {(name.string, type.string+"*")}
    | NAME '[' type=NAME ']' {(name.string, type.string)}
    | NAME {(name.string, None)}

alts[Rhs]:
    | alt "|" alts { Rhs([alt] + alts.alts)}
    | alt { Rhs([alt]) }

more_alts[Rhs]:
    | "|" alts NEWLINE more_alts { Rhs(alts.alts + more_alts.alts) }
    | "|" alts NEWLINE { Rhs(alts.alts) }

alt[Alt]:
    | items '$' action { Alt(items + [NamedItem(None, NameLeaf('ENDMARKER'))], action=action) }
    | items '$' { Alt(items + [NamedItem(None, NameLeaf('ENDMARKER'))], action=None) }
    | items action { Alt(items, action=action) }
    | items { Alt(items, action=None) }

items[NamedItemList]:
    | named_item items { [named_item] + items }
    | named_item { [named_item] }

named_item[NamedItem]:
    | NAME '=' ~ item {NamedItem(name.string, item)}
    | item {NamedItem(None, item)}
    | it=lookahead {NamedItem(None, it)}

lookahead[LookaheadOrCut]:
    | '&amp;' ~ atom {PositiveLookahead(atom)}
    | '!' ~ atom {NegativeLookahead(atom)}
    | '~' {Cut()}

item[Item]:
    | '[' ~ alts ']' {Opt(alts)}
    |  atom '?' {Opt(atom)}
    |  atom '*' {Repeat0(atom)}
    |  atom '+' {Repeat1(atom)}
    |  sep=atom '.' node=atom '+' {Gather(sep, node)}
    |  atom {atom}

atom[Plain]:
    | '(' ~ alts ')' {Group(alts)}
    | NAME {NameLeaf(name.string) }
    | STRING {StringLeaf(string.string)}

# Mini-grammar for the actions

action[str]: "{" ~ target_atoms "}" { target_atoms }

target_atoms[str]:
    | target_atom target_atoms { target_atom + " " + target_atoms }
    | target_atom { target_atom }

target_atom[str]:
    | "{" ~ target_atoms "}" { "{" + target_atoms + "}" }
    | NAME { name.string }
    | NUMBER { number.string }
    | STRING { string.string }
    | "?" { "?" }
    | ":" { ":" }
</pre></div>
</div>
<p>As an illustrative example this simple grammar file allows directly
generating a full parser that can parse simple arithmetic expressions and that
returns a valid C-based Python AST:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start[mod_ty]: a=expr_stmt* ENDMARKER { _PyAST_Module(a, NULL, p-&gt;arena) }
expr_stmt[stmt_ty]: a=expr NEWLINE { _PyAST_Expr(a, EXTRA) }

expr[expr_ty]:
    | l=expr '+' r=term { _PyAST_BinOp(l, Add, r, EXTRA) }
    | l=expr '-' r=term { _PyAST_BinOp(l, Sub, r, EXTRA) }
    | term

term[expr_ty]:
    | l=term '*' r=factor { _PyAST_BinOp(l, Mult, r, EXTRA) }
    | l=term '/' r=factor { _PyAST_BinOp(l, Div, r, EXTRA) }
    | factor

factor[expr_ty]:
    | '(' e=expr ')' { e }
    | atom

atom[expr_ty]:
    | NAME
    | NUMBER
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">EXTRA</span></code> is a macro that expands to <code class="docutils literal notranslate"><span class="pre">start_lineno,</span> <span class="pre">start_col_offset,</span>
<span class="pre">end_lineno,</span> <span class="pre">end_col_offset,</span> <span class="pre">p-&gt;arena</span></code>, those being variables automatically
injected by the parser; <code class="docutils literal notranslate"><span class="pre">p</span></code> points to an object that holds on to all state
for the parser.</p>
<p>A similar grammar written to target Python AST objects:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start[ast.Module]: a=expr_stmt* ENDMARKER { ast.Module(body=a or [] }
expr_stmt: a=expr NEWLINE { ast.Expr(value=a, EXTRA) }

expr:
    | l=expr '+' r=term { ast.BinOp(left=l, op=ast.Add(), right=r, EXTRA) }
    | l=expr '-' r=term { ast.BinOp(left=l, op=ast.Sub(), right=r, EXTRA) }
    | term

term:
    | l=term '*' r=factor { ast.BinOp(left=l, op=ast.Mult(), right=r, EXTRA) }
    | l=term '/' r=factor { ast.BinOp(left=l, op=ast.Div(), right=r, EXTRA) }
    | factor

factor:
    | '(' e=expr ')' { e }
    | atom

atom:
    | NAME
    | NUMBER
</pre></div>
</div>
</section>
</section>
<section id="pegen">
<h2>Pegen<a class="headerlink" href="#pegen" title="永久链接至标题">¶</a></h2>
<p>Pegen is the parser generator used in CPython to produce the final PEG parser used by the interpreter. It is the
program that can be used to read the python grammar located in <code class="file docutils literal notranslate"><span class="pre">Grammar/Python.gram</span></code> and produce the final C
parser. It contains the following pieces:</p>
<ul class="simple">
<li><p>A parser generator that can read a grammar file and produce a PEG parser written in Python or C that can parse
said grammar. The generator is located at <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen</span></code>.</p></li>
<li><p>A PEG meta-grammar that automatically generates a Python parser that is used for the parser generator itself
(this means that there are no manually-written parsers). The meta-grammar is
located at <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen/metagrammar.gram</span></code>.</p></li>
<li><p>A generated parser (using the parser generator) that can directly produce C and Python AST objects.</p></li>
</ul>
<p>The source code for Pegen lives at <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen</span></code> but normally all typical commands to interact
with the parser generator are executed from the main makefile.</p>
<section id="how-to-regenerate-the-parser">
<h3>How to regenerate the parser<a class="headerlink" href="#how-to-regenerate-the-parser" title="永久链接至标题">¶</a></h3>
<p>Once you have made the changes to the grammar files, to regenerate the <code class="docutils literal notranslate"><span class="pre">C</span></code>
parser (the one used by the interpreter) just execute:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make regen-pegen
</pre></div>
</div>
<p>using the <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code> in the main directory.  If you are on Windows you can
use the Visual Studio project files to regenerate the parser or to execute:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./PCbuild/build.bat --regen
</pre></div>
</div>
<p>The generated parser file is located at <code class="file docutils literal notranslate"><span class="pre">Parser/parser.c</span></code>.</p>
</section>
<section id="how-to-regenerate-the-meta-parser">
<h3>How to regenerate the meta-parser<a class="headerlink" href="#how-to-regenerate-the-meta-parser" title="永久链接至标题">¶</a></h3>
<p>The meta-grammar (the grammar that describes the grammar for the grammar files
themselves) is located at <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen/metagrammar.gram</span></code>.
Although it is very unlikely that you will ever need to modify it, if you make any modifications
to this file (in order to implement new Pegen features) you will need to regenerate
the meta-parser (the parser that parses the grammar files). To do so just execute:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make regen-pegen-metaparser
</pre></div>
</div>
<p>If you are on Windows you can use the Visual Studio project files
to regenerate the parser or to execute:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./PCbuild/build.bat --regen
</pre></div>
</div>
</section>
<section id="grammatical-elements-and-rules">
<h3>Grammatical elements and rules<a class="headerlink" href="#grammatical-elements-and-rules" title="永久链接至标题">¶</a></h3>
<p>Pegen has some special grammatical elements and rules:</p>
<ul class="simple">
<li><p>Strings with single quotes (’) (e.g. <code class="docutils literal notranslate"><span class="pre">'class'</span></code>) denote KEYWORDS.</p></li>
<li><p>Strings with double quotes (”) (e.g. <code class="docutils literal notranslate"><span class="pre">"match"</span></code>) denote SOFT KEYWORDS.</p></li>
<li><p>Upper case names (e.g. <code class="docutils literal notranslate"><span class="pre">NAME</span></code>) denote tokens in the <code class="file docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code> file.</p></li>
<li><p>Rule names starting with <cite>invalid_</cite> are used for specialized syntax errors.</p>
<ul>
<li><p>These rules are NOT used in the first pass of the parser.</p></li>
<li><p>Only if the first pass fails to parse, a second pass including the invalid
rules will be executed.</p></li>
<li><p>If the parser fails in the second phase with a generic syntax error, the
location of the generic failure of the first pass will be used (this avoids
reporting incorrect locations due to the invalid rules).</p></li>
<li><p>The order of the alternatives involving invalid rules matter
(like any rule in PEG).</p></li>
</ul>
</li>
</ul>
</section>
<section id="tokenization">
<h3>Tokenization<a class="headerlink" href="#tokenization" title="永久链接至标题">¶</a></h3>
<p>It is common among PEG parser frameworks that the parser does both the parsing and the tokenization,
but this does not happen in Pegen. The reason is that the Python language needs a custom tokenizer
to handle things like indentation boundaries, some special keywords like <code class="docutils literal notranslate"><span class="pre">ASYNC</span></code> and <code class="docutils literal notranslate"><span class="pre">AWAIT</span></code>
(for compatibility purposes), backtracking errors (such as unclosed parenthesis), dealing with encoding,
interactive mode and much more. Some of these reasons are also there for historical purposes, and some
others are useful even today.</p>
<p>The list of tokens (all uppercase names in the grammar) that you can use can be found in the <code class="file docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code>
file. If you change this file to add new tokens, make sure to regenerate the files by executing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make regen-token
</pre></div>
</div>
<p>If you are on Windows you can use the Visual Studio project files to regenerate the tokens or to execute:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./PCbuild/build.bat --regen
</pre></div>
</div>
<p>How tokens are generated and the rules governing this is completely up to the tokenizer (<code class="file docutils literal notranslate"><span class="pre">Parser/tokenizer.c</span></code>)
and the parser just receives tokens from it.</p>
</section>
<section id="memoization">
<h3>Memoization<a class="headerlink" href="#memoization" title="永久链接至标题">¶</a></h3>
<p>As described previously, to avoid exponential time complexity in the parser, memoization is used.</p>
<p>The C parser used by Python is highly optimized and memoization can be expensive both in memory and time. Although
the memory cost is obvious (the parser needs memory for storing previous results in the cache) the execution time
cost comes for continuously checking if the given rule has a cache hit or not. In many situations, just parsing it
again can be faster. Pegen <strong>disables memoization by default</strong> except for rules with the special marker <cite>memo</cite> after
the rule name (and type, if present):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rule_name[typr] (memo):
    ...
</pre></div>
</div>
<p>By selectively turning on memoization for a handful of rules, the parser becomes faster and uses less memory.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Left-recursive rules always use memoization, since the implementation of left-recursion depends on it.</p>
</div>
<p>To know if a new rule needs memoization or not, benchmarking is required
(comparing execution times and memory usage of some considerably big files with
and without memoization). There is a very simple instrumentation API available
in the generated C parse code that allows to measure how much each rule uses
memoization (check the <code class="file docutils literal notranslate"><span class="pre">Parser/pegen.c</span></code> file for more information) but it
needs to be manually activated.</p>
</section>
<section id="automatic-variables">
<h3>Automatic variables<a class="headerlink" href="#automatic-variables" title="永久链接至标题">¶</a></h3>
<p>To make writing actions easier, Pegen injects some automatic variables in the namespace available
when writing actions. In the C parser, some of these automatic variable names are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>: The parser structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EXTRA</span></code>: This is a macro that expands to <code class="docutils literal notranslate"><span class="pre">(_start_lineno,</span> <span class="pre">_start_col_offset,</span> <span class="pre">_end_lineno,</span> <span class="pre">_end_col_offset,</span> <span class="pre">p-&gt;arena)</span></code>,
which is normally used to create AST nodes as almost all constructors need these attributes to be provided. All of the
location variables are taken from the location information of the current token.</p></li>
</ul>
</section>
<section id="hard-and-soft-keywords">
<h3>Hard and Soft keywords<a class="headerlink" href="#hard-and-soft-keywords" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>In the grammar files, keywords are defined using <strong>single quotes</strong> (e.g. <cite>‘class’</cite>) while soft
keywords are defined using <strong>double quotes</strong> (e.g. <cite>“match”</cite>).</p>
</div>
<p>There are two kinds of keywords allowed in pegen grammars: <em>hard</em> and <em>soft</em>
keywords. The difference between hard and soft keywords is that hard keywords
are always reserved words, even in positions where they make no sense (e.g. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">class</span> <span class="pre">+</span> <span class="pre">1</span></code>),
while soft keywords only get a special meaning in context. Trying to use a hard
keyword as a variable will always fail:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; class = 3
File "&lt;stdin&gt;", line 1
    class = 3
        ^
SyntaxError: invalid syntax
&gt;&gt;&gt; foo(class=3)
File "&lt;stdin&gt;", line 1
    foo(class=3)
        ^^^^^
SyntaxError: invalid syntax
</pre></div>
</div>
<p>While soft keywords don’t have this limitation if used in a context other the one where they
are defined as keywords:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match</span> <span class="o">=</span> <span class="mi">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="n">match</span><span class="o">=</span><span class="s2">"Yeah!"</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">case</span></code> keywords are soft keywords, so that they are recognized as
keywords at the beginning of a match statement or case block respectively, but are
allowed to be used in other places as variable or argument names.</p>
<p>You can get a list of all keywords defined in the grammar from Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">keyword</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span>
<span class="go">['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break',</span>
<span class="go">'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for',</span>
<span class="go">'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or',</span>
<span class="go">'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</span>
</pre></div>
</div>
<p>as well as soft keywords:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">keyword</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keyword</span><span class="o">.</span><span class="n">softkwlist</span>
<span class="go">['_', 'case', 'match']</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>Soft keywords can be a bit challenging to manage as they can be accepted in
places you don’t intend to, given how the order alternatives behave in PEG
parsers (see <a class="reference internal" href="#consequences-of-ordered-choice"><span class="std std-ref">consequences of ordered choice section</span></a> for some background on this). In general,
try to define them in places where there is not a lot of alternatives.</p>
</div>
</section>
<section id="error-handling">
<h3>Error handling<a class="headerlink" href="#error-handling" title="永久链接至标题">¶</a></h3>
<p>When a pegen-generated parser detects that an exception is raised, it will
<strong>automatically stop parsing</strong>, no matter what the current state of the parser
is and it will unwind the stack and report the exception. This means that if a
<a class="reference internal" href="#peg-grammar-actions"><span class="std std-ref">rule action</span></a> raises an exception all parsing will
stop at that exact point. This is done to allow to correctly propagate any
exception set by calling Python C-API functions. This also includes <a class="reference external" href="https://daobook.github.io/cpython/library/exceptions.html#SyntaxError" title="(在 Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>
exceptions and this is the main mechanism the parser uses to report custom syntax
error messages.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Tokenizer errors are normally reported by raising exceptions but some special
tokenizer errors such as unclosed parenthesis will be reported only after the
parser finishes without returning anything.</p>
</div>
</section>
<section id="how-syntax-errors-are-reported">
<h3>How Syntax errors are reported<a class="headerlink" href="#how-syntax-errors-are-reported" title="永久链接至标题">¶</a></h3>
<p>As described previously in the <a class="reference internal" href="#id1"><span class="std std-ref">how PEG parsers work section</span></a>, PEG parsers don’t have a defined concept of where
errors happened in the grammar, because a rule failure doesn’t imply a
parsing failure like in context free grammars. This means that some heuristic
has to be used to report generic errors unless something is explicitly declared
as an error in the grammar.</p>
<p>To report generic syntax errors, pegen uses a common heuristic in PEG parsers:
the location of <em>generic</em> syntax errors is reported in the furthest token that
was attempted to be matched but failed. This is only done if parsing has failed
(the parser returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in C or <code class="docutils literal notranslate"><span class="pre">None</span></code> in Python) but no exception has
been raised.</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>Positive and negative lookaheads will try to match a token so they will affect
the location of generic syntax errors. Use them carefully at boundaries
between rules.</p>
</div>
<p>As the Python grammar was primordially written as an LL(1) grammar, this heuristic
has an extremely high success rate, but some PEG features can have small effects,
such as <a class="reference internal" href="#peg-positive-lookahead"><span class="std std-ref">positive lookaheads</span></a> and
<a class="reference internal" href="#peg-negative-lookahead"><span class="std std-ref">negative lookaheads</span></a>.</p>
<p>To generate more precise syntax errors, custom rules are used. This is a common practice
also in context free grammars: the parser will try to accept some construct that is known
to be incorrect just to report a specific syntax error for that construct. In pegen grammars,
these rules start with the <code class="docutils literal notranslate"><span class="pre">invalid_</span></code> prefix. This is because trying to match these rules
normally has a performance impact on parsing (and can also affect the ‘correct’ grammar itself
in some tricky cases, depending on the ordering of the rules) so the generated parser acts in
two phases:</p>
<ol class="arabic simple">
<li><p>The first phase will try to parse the input stream without taking into account rules that
start with the <code class="docutils literal notranslate"><span class="pre">invalid_</span></code> prefix. If the parsing succeeds it will return the generated AST
and the second phase will not be attempted.</p></li>
<li><p>If the first phase failed, a second parsing attempt is done including the rules that start
with an <code class="docutils literal notranslate"><span class="pre">invalid_</span></code> prefix. By design this attempt <strong>cannot succeed</strong> and is only executed
to give to the invalid rules a chance to detect specific situations where custom, more precise,
syntax errors can be raised. This also allows to trade a bit of performance for precision reporting
errors: given that we know that the input text is invalid, there is no need to be fast because
the interpreter is going to stop anyway.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>When defining invalid rules:</p>
<ul class="simple">
<li><p>Make sure all custom invalid rules raise <a class="reference external" href="https://daobook.github.io/cpython/library/exceptions.html#SyntaxError" title="(在 Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> exceptions (or a subclass of it).</p></li>
<li><p>Make sure <strong>all</strong> invalid rules start with the <code class="docutils literal notranslate"><span class="pre">invalid_</span></code> prefix to not
impact performance of parsing correct Python code.</p></li>
<li><p>Make sure the parser doesn’t behave differently for regular rules when you introduce invalid rules
(see the <a class="reference internal" href="#id1"><span class="std std-ref">how PEG parsers work section</span></a> for more information).</p></li>
</ul>
</div>
<p>You can find a collection of macros to raise specialized syntax errors in the
<code class="file docutils literal notranslate"><span class="pre">Parser/pegen.h</span></code> header file. These macros allow also to report ranges for
the custom errors that will be highlighted in the tracebacks that will be
displayed when the error is reported.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>A good way to test if an invalid rule will be triggered when you expect is to test if introducing
a syntax error <strong>after</strong> valid code triggers the rule or not. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;valid python code&gt; $ 42
</pre></div>
</div>
<p>Should trigger the syntax error in the <code class="docutils literal notranslate"><span class="pre">$</span></code> character. If your rule is not correctly defined this
won’t happen. For example, if you try to define a rule to match Python 2 style <code class="docutils literal notranslate"><span class="pre">print</span></code> statements
to make a better error message and you define it as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>invalid_print: "print" expression
</pre></div>
</div>
<p>This will <strong>seem</strong> to work because the parser will correctly parse <code class="docutils literal notranslate"><span class="pre">print(something)</span></code> because it is valid
code and the second phase will never execute but if you try to parse <code class="docutils literal notranslate"><span class="pre">print(something)</span> <span class="pre">$</span> <span class="pre">3</span></code> the first pass
of the parser will fail (because of the <code class="docutils literal notranslate"><span class="pre">$</span></code>) and in the second phase, the rule will match the
<code class="docutils literal notranslate"><span class="pre">print(something)</span></code> as <code class="docutils literal notranslate"><span class="pre">print</span></code> followed by the variable <code class="docutils literal notranslate"><span class="pre">something</span></code> between parentheses and the error
will be reported there instead of the <code class="docutils literal notranslate"><span class="pre">$</span></code> character.</p>
</div>
</section>
<section id="generating-ast-objects">
<h3>Generating AST objects<a class="headerlink" href="#generating-ast-objects" title="永久链接至标题">¶</a></h3>
<p>The output of the C parser used by CPython that is generated by the
<code class="file docutils literal notranslate"><span class="pre">Grammar/Python.gram</span></code> grammar file is a Python AST object (using C
structures). This means that the actions in the grammar file generate AST objects
when they succeed. Constructing these objects can be quite cumbersome (see
the <a class="reference internal" href="compiler.html#compiler-ast-trees"><span class="std std-ref">AST compiler section</span></a> for more information
on how these objects are constructed and how they are used by the compiler) so
special helper functions are used. These functions are declared in the
<code class="file docutils literal notranslate"><span class="pre">Parser/pegen.h</span></code> header file and defined in the <code class="file docutils literal notranslate"><span class="pre">Parser/action_helpers.c</span></code>
file. These functions allow you to join AST sequences, get specific elements
from them or to do extra processing on the generated tree.</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>Actions must <strong>never</strong> be used to accept or reject rules. It may be tempting
in some situations to write a very generic rule and then check the generated
AST to decide if is valid or not but this will render the <a class="reference external" href="https://docs.python.org/3/reference/grammar.html">official grammar</a> partially incorrect
(because actions are not included) and will make it more difficult for other
Python implementations to adapt the grammar to their own needs.</p>
</div>
<p>As a general rule, if an action spawns multiple lines or requires something more
complicated than a single expression of C code, is normally better to create a
custom helper in <code class="file docutils literal notranslate"><span class="pre">Parser/action_helpers.c</span></code> and expose it in the
<code class="file docutils literal notranslate"><span class="pre">Parser/pegen.h</span></code> header file so it can be used from the grammar.</p>
<p>If the parsing succeeds, the parser <strong>must</strong> return a <strong>valid</strong> AST object.</p>
</section>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="永久链接至标题">¶</a></h2>
<p>There are three files that contain tests for the grammar and the parser:</p>
<ul class="simple">
<li><p><cite>Lib/test/test_grammar.py</cite>.</p></li>
<li><p><cite>Lib/test/test_syntax.py</cite>.</p></li>
<li><p><cite>Lib/test/test_exceptions.py</cite>.</p></li>
</ul>
<p>Check the contents of these files to know which is the best place to place new tests depending
on the nature of the new feature you are adding.</p>
<p>Tests for the parser generator itself can be found in the <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_peg_generator</span></code> directory.</p>
</section>
<section id="debugging-generated-parsers">
<h2>Debugging generated parsers<a class="headerlink" href="#debugging-generated-parsers" title="永久链接至标题">¶</a></h2>
<section id="making-experiments">
<h3>Making experiments<a class="headerlink" href="#making-experiments" title="永久链接至标题">¶</a></h3>
<p>As the generated C parser is the one used by Python, this means that if something goes wrong when adding some
new rules to the grammar you cannot correctly compile and execute Python anymore. This makes it a bit challenging
to debug when something goes wrong, especially when making experiments.</p>
<p>For this reason it is a good idea to experiment first by generating a Python parser. To do this, you can go to the
<code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/</span></code> directory on the CPython repository and manually call the parser generator by executing:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python -m pegen python &lt;PATH TO YOUR GRAMMAR FILE&gt;
</pre></div>
</div>
<p>This will generate a file called <code class="file docutils literal notranslate"><span class="pre">parse.py</span></code> in the same directory that you can use to parse some input:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python parse.py file_with_source_code_to_test.py
</pre></div>
</div>
<p>As the generated <code class="file docutils literal notranslate"><span class="pre">parse.py</span></code> file is just Python code, you can modify it and add breakpoints to debug or
better understand some complex situations.</p>
</section>
<section id="verbose-mode">
<h3>Verbose mode<a class="headerlink" href="#verbose-mode" title="永久链接至标题">¶</a></h3>
<p>When Python is compiled in debug mode (by adding <code class="docutils literal notranslate"><span class="pre">--with-pydebug</span></code> when running the configure step in Linux or by
adding <code class="docutils literal notranslate"><span class="pre">-d</span></code> when calling the <code class="file docutils literal notranslate"><span class="pre">PCbuild/python.bat</span></code> script in Windows), it is possible to activate a <strong>very</strong> verbose
mode in the generated parser. This is very useful to debug the generated parser and to understand how it works, but it
can be a bit hard to understand at first.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>When activating verbose mode in the Python parser, it is better to not use interactive mode as it can be much harder to
understand, because interactive mode involves some special steps compared to regular parsing.</p>
</div>
<p>To activate verbose mode you can add the <code class="docutils literal notranslate"><span class="pre">-d</span></code> flag when executing Python:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ python -d file_to_test.py
</pre></div>
</div>
<p>This will print <strong>a lot</strong> of output to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> so is probably better to dump it to a file for further analysis. The output
consists of trace lines with the following structure:</p>
<blockquote>
<div><p>&lt;indentation&gt; (‘&gt;’|’-‘|’+’|’!’) &lt;rule_name&gt;[&lt;token_location&gt;]: &lt;alternative&gt; …</p>
</div></blockquote>
<p>Every line is indented by a different amount (<code class="docutils literal notranslate"><span class="pre">&lt;indentation&gt;</span></code>) depending on how deep the call stack is. The next
character marks the type of the trace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code> indicates that a rule is going to be attempted to be parsed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code> indicates that a rule has failed to be parsed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code> indicates that a rule has been parsed correctly.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!</span></code> indicates that an exception or an error has been detected and the parser is unwinding.</p></li>
</ul>
<p>The &lt;token_location&gt; part indicates the current index in the token array, the
&lt;rule_name&gt; part indicates what rule is being parsed and the &lt;alternative&gt; part
indicates what alternative within that rule is being attempted.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="永久链接至标题">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Ford, Bryan
<a class="reference external" href="http://pdos.csail.mit.edu/~baford/packrat/thesis">http://pdos.csail.mit.edu/~baford/packrat/thesis</a></p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id9">2</a></span></dt>
<dd><p>Medeiros et al.
<a class="reference external" href="https://arxiv.org/pdf/1207.0443.pdf">https://arxiv.org/pdf/1207.0443.pdf</a></p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id10">3</a></span></dt>
<dd><p>Warth et al.
<a class="reference external" href="http://web.cs.ucla.edu/~todd/research/pepm08.pdf">http://web.cs.ucla.edu/~todd/research/pepm08.pdf</a></p>
</dd>
</dl>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="compiler.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Design of CPython’s Compiler</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="grammar.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Changing CPython’s Grammar</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2011-2022, Python Software Foundation |
            最后更新于 3月 10, 2022. |
          Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
          <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
            | <a class="muted-link" href="_sources/parser.rst.txt"
               rel="nofollow">
              显示源代码
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Guide to CPython’s Parser</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#how-peg-parsers-work">How PEG Parsers Work</a><ul>
<li><a class="reference internal" href="#key-ideas">Key ideas</a></li>
<li><a class="reference internal" href="#consequences-or-the-ordered-choice-operator">Consequences or the ordered choice operator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#syntax">Syntax</a><ul>
<li><a class="reference internal" href="#grammar-expressions">Grammar Expressions</a><ul>
<li><a class="reference internal" href="#comment"><code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">comment</span></code></a></li>
<li><a class="reference internal" href="#e1-e2"><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">e2</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">|</span> <span class="pre">e2</span></code></a></li>
<li><a class="reference internal" href="#e"><code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">e</span> <span class="pre">)</span></code></a></li>
<li><a class="reference internal" href="#e-or-e"><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">e</span> <span class="pre">]</span> <span class="pre">or</span> <span class="pre">e?</span></code></a></li>
<li><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">e*</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">e+</span></code></a></li>
<li><a class="reference internal" href="#s-e"><code class="docutils literal notranslate"><span class="pre">s.e+</span></code></a></li>
<li><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">&amp;e</span></code></a></li>
<li><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">!e</span></code></a></li>
<li><a class="reference internal" href="#id8"><code class="docutils literal notranslate"><span class="pre">~</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#left-recursion">Left recursion</a></li>
<li><a class="reference internal" href="#variables-in-the-grammar">Variables in the Grammar</a></li>
<li><a class="reference internal" href="#grammar-actions">Grammar actions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pegen">Pegen</a><ul>
<li><a class="reference internal" href="#how-to-regenerate-the-parser">How to regenerate the parser</a></li>
<li><a class="reference internal" href="#how-to-regenerate-the-meta-parser">How to regenerate the meta-parser</a></li>
<li><a class="reference internal" href="#grammatical-elements-and-rules">Grammatical elements and rules</a></li>
<li><a class="reference internal" href="#tokenization">Tokenization</a></li>
<li><a class="reference internal" href="#memoization">Memoization</a></li>
<li><a class="reference internal" href="#automatic-variables">Automatic variables</a></li>
<li><a class="reference internal" href="#hard-and-soft-keywords">Hard and Soft keywords</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
<li><a class="reference internal" href="#how-syntax-errors-are-reported">How Syntax errors are reported</a></li>
<li><a class="reference internal" href="#generating-ast-objects">Generating AST objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#debugging-generated-parsers">Debugging generated parsers</a><ul>
<li><a class="reference internal" href="#making-experiments">Making experiments</a></li>
<li><a class="reference internal" href="#verbose-mode">Verbose mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    </body>
</html>