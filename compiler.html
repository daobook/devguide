<!doctype html>
<html class="no-js" lang="zh_CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="Design of CPython’s Garbage Collector" href="garbage_collector.html" /><link rel="prev" title="Guide to CPython’s Parser" href="parser.html" />

    <meta name="generator" content="sphinx-4.3.0, furo 2021.11.16"/>
        <title>Design of CPython’s Compiler - Python Developer&#39;s Guide</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=916d6ed8f59335acffa15474ff504849343d4c76" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=0af69da206d614734f649b27d4cdc2dd6c31f41d" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Python Developer's Guide </div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/python-logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Python Developer's Guide </span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=搜索 name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Where to Get Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="pullrequest.html">Lifecycle of a Pull Request</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtests.html">Running &amp; Writing Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverage.html">Increase Test Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="docquality.html">Helping with Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documenting.html">Documenting Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="silencewarnings.html">Silence Warnings From the Test Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="fixingissues.html">Fixing “easy” Issues (and Beyond)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tracker.html">Issue Tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="triaging.html">Triaging an Issue</a></li>
<li class="toctree-l1"><a class="reference internal" href="communication.html">Following Python’s Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="porting.html">Porting Python to a new platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="coredev.html">How to Become a Core Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developer Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="committing.html">Accepting Pull Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="devcycle.html">Development Cycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildbots.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="stdlibchanges.html">Adding to the Stdlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="langchanges.html">Changing the Python Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="experts.html">Experts Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="gdb.html">gdb Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="exploring.html">Exploring CPython’s Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">Changing CPython’s Grammar</a></li>
<li class="toctree-l1"><a class="reference internal" href="parser.html">Guide to CPython’s Parser</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Design of CPython’s Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="garbage_collector.html">Design of CPython’s Garbage Collector</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">Updating standard library extension modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">Changing Python’s C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="coverity.html">Coverity Scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="clang.html">Dynamic Analysis with Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="buildworker.html">Running a buildbot worker</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivations.html">Core Developer Motivations and Affiliations</a></li>
<li class="toctree-l1"><a class="reference internal" href="gitbootcamp.html">Git Bootcamp and Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix: Topics</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="design-of-cpython-s-compiler">
<span id="compiler"></span><h1>Design of CPython’s Compiler<a class="headerlink" href="#design-of-cpython-s-compiler" title="永久链接至标题">¶</a></h1>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>In CPython, the compilation from source code to bytecode involves several steps:</p>
<ol class="arabic simple">
<li><p>Tokenize the source code (<code class="file docutils literal notranslate"><span class="pre">Parser/tokenizer.c</span></code>)</p></li>
<li><p>Parse the stream of tokens into an Abstract Syntax Tree (<code class="file docutils literal notranslate"><span class="pre">Parser/parser.c</span></code>)</p></li>
<li><p>Transform AST into a Control Flow Graph (<code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>)</p></li>
<li><p>Emit bytecode based on the Control Flow Graph (<code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>)</p></li>
</ol>
<p>The purpose of this document is to outline how these steps of the process work.</p>
<p>This document does not touch on how parsing works beyond what is needed
to explain what is needed for compilation.  It is also not exhaustive
in terms of the how the entire system works.  You will most likely need
to read some source to have an exact understanding of all details.</p>
</section>
<section id="parsing">
<h2>Parsing<a class="headerlink" href="#parsing" title="永久链接至标题">¶</a></h2>
<p>As of Python 3.9, Python’s parser is a PEG parser of a somewhat
unusual design (since its input is a stream of tokens rather than a
stream of characters as is more common with PEG parsers).</p>
<p>The grammar file for Python can be found in
<code class="file docutils literal notranslate"><span class="pre">Grammar/python.gram</span></code>.  The definitions for literal tokens
(such as <code class="docutils literal notranslate"><span class="pre">:</span></code>, numbers, etc.) can be found in <code class="file docutils literal notranslate"><span class="pre">Grammar/Tokens</span></code>.
Various C files, including <code class="file docutils literal notranslate"><span class="pre">Parser/parser.c</span></code> are generated from
these (see <a class="reference internal" href="grammar.html"><span class="doc">Changing CPython’s Grammar</span></a>).</p>
</section>
<section id="abstract-syntax-trees-ast">
<h2>Abstract Syntax Trees (AST)<a class="headerlink" href="#abstract-syntax-trees-ast" title="永久链接至标题">¶</a></h2>
<aside class="sidebar">
<p class="sidebar-title">Green Tree Snakes</p>
<p>See also <a class="reference external" href="https://greentreesnakes.readthedocs.io/en/latest/">Green Tree Snakes - the missing Python AST docs</a> by Thomas Kluyver.</p>
</aside>
<p>The abstract syntax tree (AST) is a high-level representation of the
program structure without the necessity of containing the source code;
it can be thought of as an abstract representation of the source code.  The
specification of the AST nodes is specified using the Zephyr Abstract
Syntax Definition Language (ASDL) <a class="reference internal" href="#wang97" id="id1"><span>[Wang97]</span></a>.</p>
<p>The definition of the AST nodes for Python is found in the file
<code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code>.</p>
<p>Each AST node (representing statements, expressions, and several
specialized types, like list comprehensions and exception handlers) is
defined by the ASDL.  Most definitions in the AST correspond to a
particular source construct, such as an ‘if’ statement or an attribute
lookup.  The definition is independent of its realization in any
particular programming language.</p>
<p>The following fragment of the Python ASDL construct demonstrates the
approach and syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module Python
{
    stmt = FunctionDef(identifier name, arguments args, stmt* body,
                       expr* decorators)
           | Return(expr? value) | Yield(expr? value)
           attributes (int lineno)
}
</pre></div>
</div>
<p>The preceding example describes two different kinds of statements and an
expression: function definitions, return statements, and yield expressions.
All three kinds are considered of type <code class="docutils literal notranslate"><span class="pre">stmt</span></code> as shown by <code class="docutils literal notranslate"><span class="pre">|</span></code> separating
the various kinds.  They all take arguments of various kinds and amounts.</p>
<p>Modifiers on the argument type specify the number of values needed; <code class="docutils literal notranslate"><span class="pre">?</span></code>
means it is optional, <code class="docutils literal notranslate"><span class="pre">*</span></code> means 0 or more, while no modifier means only one
value for the argument and it is required.  <code class="docutils literal notranslate"><span class="pre">FunctionDef</span></code>, for instance,
takes an <code class="docutils literal notranslate"><span class="pre">identifier</span></code> for the <em>name</em>, <code class="docutils literal notranslate"><span class="pre">arguments</span></code> for <em>args</em>, zero or more
<code class="docutils literal notranslate"><span class="pre">stmt</span></code> arguments for <em>body</em>, and zero or more <code class="docutils literal notranslate"><span class="pre">expr</span></code> arguments for
<em>decorators</em>.</p>
<p>Do notice that something like ‘arguments’, which is a node type, is
represented as a single AST node and not as a sequence of nodes as with
stmt as one might expect.</p>
<p>All three kinds also have an ‘attributes’ argument; this is shown by the
fact that ‘attributes’ lacks a ‘|’ before it.</p>
<p>The statement definitions above generate the following C structure type:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">_stmt</span><span class="w"> </span><span class="o">*</span><span class="n">stmt_ty</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">_stmt</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">FunctionDef_kind</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Return_kind</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">Yield_kind</span><span class="o">=</span><span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">kind</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">identifier</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">                      </span><span class="n">arguments_ty</span><span class="w"> </span><span class="n">args</span><span class="p">;</span><span class="w"></span>
<span class="w">                      </span><span class="n">asdl_seq</span><span class="w"> </span><span class="o">*</span><span class="n">body</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"> </span><span class="n">FunctionDef</span><span class="p">;</span><span class="w"></span>

<span class="w">              </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">expr_ty</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"> </span><span class="n">Return</span><span class="p">;</span><span class="w"></span>

<span class="w">              </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">expr_ty</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"> </span><span class="n">Yield</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">lineno</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Also generated are a series of constructor functions that allocate (in
this case) a <code class="docutils literal notranslate"><span class="pre">stmt_ty</span></code> struct with the appropriate initialization.  The
<code class="docutils literal notranslate"><span class="pre">kind</span></code> field specifies which component of the union is initialized.  The
<code class="docutils literal notranslate"><span class="pre">FunctionDef()</span></code> constructor function sets ‘kind’ to <code class="docutils literal notranslate"><span class="pre">FunctionDef_kind</span></code> and
initializes the <em>name</em>, <em>args</em>, <em>body</em>, and <em>attributes</em> fields.</p>
</section>
<section id="memory-management">
<h2>Memory Management<a class="headerlink" href="#memory-management" title="永久链接至标题">¶</a></h2>
<p>Before discussing the actual implementation of the compiler, a discussion of
how memory is handled is in order.  To make memory management simple, an arena
is used.  This means that a memory is pooled in a single location for easy
allocation and removal.  What this gives us is the removal of explicit memory
deallocation.  Because memory allocation for all needed memory in the compiler
registers that memory with the arena, a single call to free the arena is all
that is needed to completely free all memory used by the compiler.</p>
<p>In general, unless you are working on the critical core of the compiler, memory
management can be completely ignored.  But if you are working at either the
very beginning of the compiler or the end, you need to care about how the arena
works.  All code relating to the arena is in either
<code class="file docutils literal notranslate"><span class="pre">Include/Internal/pycore_pyarena.h</span></code> or <code class="file docutils literal notranslate"><span class="pre">Python/pyarena.c</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">PyArena_New()</span></code> will create a new arena.  The returned <code class="docutils literal notranslate"><span class="pre">PyArena</span></code> structure
will store pointers to all memory given to it.  This does the bookkeeping of
what memory needs to be freed when the compiler is finished with the memory it
used. That freeing is done with <code class="docutils literal notranslate"><span class="pre">PyArena_Free()</span></code>.  This only needs to be
called in strategic areas where the compiler exits.</p>
<p>As stated above, in general you should not have to worry about memory
management when working on the compiler.  The technical details have been
designed to be hidden from you for most cases.</p>
<p>The only exception comes about when managing a PyObject.  Since the rest
of Python uses reference counting, there is extra support added
to the arena to cleanup each PyObject that was allocated.  These cases
are very rare.  However, if you’ve allocated a PyObject, you must tell
the arena about it by calling <code class="docutils literal notranslate"><span class="pre">PyArena_AddPyObject()</span></code>.</p>
</section>
<section id="source-code-to-ast">
<h2>Source Code to AST<a class="headerlink" href="#source-code-to-ast" title="永久链接至标题">¶</a></h2>
<p>The AST is generated from source code using the function
<code class="docutils literal notranslate"><span class="pre">_PyParser_ASTFromString()</span></code> or <code class="docutils literal notranslate"><span class="pre">_PyParser_ASTFromFile()</span></code>
(from <code class="file docutils literal notranslate"><span class="pre">Parser/peg_api.c</span></code>) depending on the input type.</p>
<p>After some checks, a helper function in <code class="file docutils literal notranslate"><span class="pre">Parser/parser.c</span></code> begins applying
production rules on the source code it receives; converting source code to
tokens and matching these tokens recursively to their corresponding rule.  The
rule’s corresponding rule function is called on every match.  These rule
functions follow the format <code class="samp docutils literal notranslate"><span class="pre">xx_rule</span></code>.  Where <em>xx</em> is the grammar rule
that the function handles and is automatically derived from
<code class="file docutils literal notranslate"><span class="pre">Grammar/python.gram</span></code> by <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen/c_generator.py</span></code>.</p>
<p>Each rule function in turn creates an AST node as it goes along.  It does this
by allocating all the new nodes it needs, calling the proper AST node creation
functions for any required supporting functions and connecting them as needed.
This continues until all nonterminal symbols are replaced with terminals.  If an
error occurs, the rule functions backtrack and try another rule function.  If
there are no more rules, an error is set and the parsing ends.</p>
<p>The AST node creation helper functions have the name <code class="samp docutils literal notranslate"><span class="pre">_PyAST_</span><em><span class="pre">xx</span></em></code>
where <em>xx</em> is the AST node that the function creates.  These are defined by the
ASDL grammar and contained in <code class="file docutils literal notranslate"><span class="pre">Python/Python-ast.c</span></code> (which is generated by
<code class="file docutils literal notranslate"><span class="pre">Parser/asdl_c.py</span></code> from <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code>).  This all leads to a
sequence of AST nodes stored in <code class="docutils literal notranslate"><span class="pre">asdl_seq</span></code> structs.</p>
<p>To demonstrate everything explained so far, here’s the
rule function responsible for a simple named import statement such as
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">sys</span></code>.  Note that error-checking and debugging code has been
omitted.  Removed parts are represented by <code class="docutils literal notranslate"><span class="pre">...</span></code>.
Furthermore, some comments have been added for explanation.  These comments
may not be present in the actual code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is the production rule (from python.gram) the rule function</span>
<span class="c1">// corresponds to:</span>
<span class="c1">// import_name: 'import' dotted_as_names</span>
<span class="k">static</span><span class="w"> </span><span class="n">stmt_ty</span><span class="w"></span>
<span class="nf">import_name_rule</span><span class="p">(</span><span class="n">Parser</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">stmt_ty</span><span class="w"> </span><span class="n">_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// 'import' dotted_as_names</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">Token</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_keyword</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">asdl_alias_seq</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// The tokenizing steps.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">_keyword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_PyPegen_expect_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="mi">513</span><span class="p">))</span><span class="w">  </span><span class="c1">// token='import'</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dotted_as_names_rule</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w">  </span><span class="c1">// dotted_as_names</span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">...</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Generate an AST for the import statement.</span>
<span class="w">            </span><span class="n">_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_PyAST_Import</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="w">            </span><span class="p">...</span><span class="w"></span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">done</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="nl">done</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">_res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>To improve backtracking performance, some rules (chosen by applying a
<code class="docutils literal notranslate"><span class="pre">(memo)</span></code> flag in the grammar file) are memoized.  Each rule function checks if
a memoized version exists and returns that if so, else it continues in the
manner stated in the previous paragraphs.</p>
<p>There are macros for creating and using <code class="docutils literal notranslate"><span class="pre">asdl_xx_seq</span> <span class="pre">*</span></code> types, where <em>xx</em> is
a type of the ASDL sequence.  Three main types are defined
manually – <code class="docutils literal notranslate"><span class="pre">generic</span></code>, <code class="docutils literal notranslate"><span class="pre">identifier</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code>.  These types are found in
<code class="file docutils literal notranslate"><span class="pre">Python/asdl.c</span></code> and its corresponding header file
<code class="file docutils literal notranslate"><span class="pre">Include/Internal/pycore_asdl.h</span></code>.  Functions and macros
for creating <code class="docutils literal notranslate"><span class="pre">asdl_xx_seq</span> <span class="pre">*</span></code> types are as follows:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_Py_asdl_generic_seq_new(Py_ssize_t,</span> <span class="pre">PyArena</span> <span class="pre">*)</span></code></dt><dd><p>Allocate memory for an <code class="docutils literal notranslate"><span class="pre">asdl_int_seq</span></code> of the specified length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_Py_asdl_identifier_seq_new(Py_ssize_t,</span> <span class="pre">PyArena</span> <span class="pre">*)</span></code></dt><dd><p>Allocate memory for an <code class="docutils literal notranslate"><span class="pre">asdl_identifier_seq</span></code> of the specified length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_Py_asdl_int_seq_new(Py_ssize_t,</span> <span class="pre">PyArena</span> <span class="pre">*)</span></code></dt><dd><p>Allocate memory for an <code class="docutils literal notranslate"><span class="pre">asdl_generic_seq</span></code> of the specified length</p>
</dd>
</dl>
<p>In addition to the three types mentioned above, some ASDL sequence types are
automatically generated by <code class="file docutils literal notranslate"><span class="pre">Parser/asdl_c.py</span></code> and found in
<code class="file docutils literal notranslate"><span class="pre">Include/Internal/pycore_ast.h</span></code>.  Macros for using both manually defined
and automatically generated ASDL sequence types are as follows:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">asdl_seq_GET(asdl_xx_seq</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>Get item held at a specific position in an <code class="docutils literal notranslate"><span class="pre">asdl_xx_seq</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asdl_seq_SET(asdl_xx_seq</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">stmt_ty)</span></code></dt><dd><p>Set a specific index in an <code class="docutils literal notranslate"><span class="pre">asdl_xx_seq</span></code> to the specified value</p>
</dd>
</dl>
<p>Untyped counterparts exist for some of the typed macros.  These are useful
when a function needs to manipulate a generic ASDL sequence:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">asdl_seq_GET_UNTYPED(asdl_seq</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>Get item held at a specific position in an <code class="docutils literal notranslate"><span class="pre">asdl_seq</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asdl_seq_SET_UNTYPED(asdl_seq</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">stmt_ty)</span></code></dt><dd><p>Set a specific index in an <code class="docutils literal notranslate"><span class="pre">asdl_seq</span></code> to the specified value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asdl_seq_LEN(asdl_seq</span> <span class="pre">*)</span></code></dt><dd><p>Return the length of an <code class="docutils literal notranslate"><span class="pre">asdl_seq</span></code> or <code class="docutils literal notranslate"><span class="pre">asdl_xx_seq</span></code></p>
</dd>
</dl>
<p>Note that typed macros and functions are recommended over their untyped
counterparts.  Typed macros carry out checks in debug mode and aid
debugging errors caused by incorrectly casting from <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.</p>
<p>If you are working with statements, you must also worry about keeping
track of what line number generated the statement.  Currently the line
number is passed as the last parameter to each <code class="docutils literal notranslate"><span class="pre">stmt_ty</span></code> function.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>The new PEG parser generates an AST directly without creating a
parse tree. <code class="docutils literal notranslate"><span class="pre">Python/ast.c</span></code> is now only used to validate the AST for
debugging purposes.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0617"><strong>PEP 617</strong></a> (PEP 617 – New PEG parser for CPython)</p>
</div>
</section>
<section id="control-flow-graphs">
<h2>Control Flow Graphs<a class="headerlink" href="#control-flow-graphs" title="永久链接至标题">¶</a></h2>
<p>A <em>control flow graph</em> (often referenced by its acronym, CFG) is a
directed graph that models the flow of a program.  A node of a CFG is
not an individual bytecode instruction, but instead represents a
sequence of bytecode instructions that always execute sequentially.
Each node is called a <em>basic block</em> and must always execute from
start to finish, with a single entry point at the beginning and a
single exit point at the end.  If some bytecode instruction <em>a</em> needs
to jump to some other bytecode instruction <em>b</em>, then <em>a</em> must occur at
the end of its basic block, and <em>b</em> must occur at the start of its
basic block.</p>
<p>As an example, consider the following code snippet:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">f1</span><span class="p">()</span>
    <span class="n">f2</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">g</span><span class="p">()</span>
<span class="n">end</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">10</span></code> guard is represented by its own basic block that
compares <code class="docutils literal notranslate"><span class="pre">x</span></code> with <code class="docutils literal notranslate"><span class="pre">10</span></code> and then ends in a conditional jump based on
the result of the comparison.  This conditional jump allows the block
to point to both the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> and the body of the <code class="docutils literal notranslate"><span class="pre">else</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">if</span></code> basic block contains the <code class="docutils literal notranslate"><span class="pre">f1()</span></code> and <code class="docutils literal notranslate"><span class="pre">f2()</span></code> calls and points to
the <code class="docutils literal notranslate"><span class="pre">end()</span></code> basic block. The <code class="docutils literal notranslate"><span class="pre">else</span></code> basic block contains the <code class="docutils literal notranslate"><span class="pre">g()</span></code>
call and similarly points to the <code class="docutils literal notranslate"><span class="pre">end()</span></code> block.</p>
<p>Note that more complex code in the guard, the <code class="docutils literal notranslate"><span class="pre">if</span></code> body, or the <code class="docutils literal notranslate"><span class="pre">else</span></code>
body may be represented by multiple basic blocks. For instance,
short-circuiting boolean logic in a guard like <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">or</span> <span class="pre">y:</span></code>
will produce one basic block that tests the truth value of <code class="docutils literal notranslate"><span class="pre">x</span></code>
and then points both (1) to the start of the <code class="docutils literal notranslate"><span class="pre">if</span></code> body and (2) to
a different basic block that tests the truth value of y.</p>
<p>CFGs are usually one step away from final code output.  Code is directly
generated from the basic blocks (with jump targets adjusted based on the
output order) by doing a post-order depth-first search on the CFG
following the edges.</p>
</section>
<section id="ast-to-cfg-to-bytecode">
<h2>AST to CFG to Bytecode<a class="headerlink" href="#ast-to-cfg-to-bytecode" title="永久链接至标题">¶</a></h2>
<p>With the AST created, the next step is to create the CFG. The first step
is to convert the AST to Python bytecode without having jump targets
resolved to specific offsets (this is calculated when the CFG goes to
final bytecode). Essentially, this transforms the AST into Python
bytecode with control flow represented by the edges of the CFG.</p>
<p>Conversion is done in two passes.  The first creates the namespace
(variables can be classified as local, free/cell for closures, or
global).  With that done, the second pass essentially flattens the CFG
into a list and calculates jump offsets for final output of bytecode.</p>
<p>The conversion process is initiated by a call to the function
<code class="docutils literal notranslate"><span class="pre">_PyAST_Compile()</span></code> in <code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>.  This function does both the
conversion of the AST to a CFG and outputting final bytecode from the CFG.
The AST to CFG step is handled mostly by two functions called by
<code class="docutils literal notranslate"><span class="pre">_PyAST_Compile()</span></code>; <code class="docutils literal notranslate"><span class="pre">_PySymtable_Build()</span></code> and <code class="docutils literal notranslate"><span class="pre">compiler_mod()</span></code>.  The former
is in <code class="file docutils literal notranslate"><span class="pre">Python/symtable.c</span></code> while the latter is in <code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">_PySymtable_Build()</span></code> begins by entering the starting code block for the
AST (passed-in) and then calling the proper <code class="samp docutils literal notranslate"><span class="pre">symtable_visit_</span><em><span class="pre">xx</span></em></code> function
(with <em>xx</em> being the AST node type).  Next, the AST tree is walked with
the various code blocks that delineate the reach of a local variable
as blocks are entered and exited using <code class="docutils literal notranslate"><span class="pre">symtable_enter_block()</span></code> and
<code class="docutils literal notranslate"><span class="pre">symtable_exit_block()</span></code>, respectively.</p>
<p>Once the symbol table is created, it is time for CFG creation, whose
code is in <code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>.  This is handled by several functions
that break the task down by various AST node types.  The functions are
all named <code class="samp docutils literal notranslate"><span class="pre">compiler_visit_</span><em><span class="pre">xx</span></em></code> where <em>xx</em> is the name of the node type (such
as <code class="docutils literal notranslate"><span class="pre">stmt</span></code>, <code class="docutils literal notranslate"><span class="pre">expr</span></code>, etc.).  Each function receives a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compiler</span> <span class="pre">*</span></code>
and <code class="samp docutils literal notranslate"><em><span class="pre">xx</span></em><span class="pre">_ty</span></code> where <em>xx</em> is the AST node type.  Typically these functions
consist of a large ‘switch’ statement, branching based on the kind of
node type passed to it.  Simple things are handled inline in the
‘switch’ statement with more complex transformations farmed out to other
functions named <code class="samp docutils literal notranslate"><span class="pre">compiler_</span><em><span class="pre">xx</span></em></code> with <em>xx</em> being a descriptive name of what is
being handled.</p>
<p>When transforming an arbitrary AST node, use the <code class="docutils literal notranslate"><span class="pre">VISIT()</span></code> macro.
The appropriate <code class="samp docutils literal notranslate"><span class="pre">compiler_visit_</span><em><span class="pre">xx</span></em></code> function is called, based on the value
passed in for &lt;node type&gt; (so <code class="samp docutils literal notranslate"><span class="pre">VISIT(</span><em><span class="pre">c</span></em><span class="pre">,</span> <span class="pre">expr,</span> <em><span class="pre">node</span></em><span class="pre">)</span></code> calls
<code class="samp docutils literal notranslate"><span class="pre">compiler_visit_expr(</span><em><span class="pre">c</span></em><span class="pre">,</span> <em><span class="pre">node</span></em><span class="pre">)</span></code>).  The <code class="docutils literal notranslate"><span class="pre">VISIT_SEQ()</span></code> macro is very similar,
but is called on AST node sequences (those values that were created as
arguments to a node that used the ‘*’ modifier).  There is also
<code class="docutils literal notranslate"><span class="pre">VISIT_SLICE()</span></code> just for handling slices.</p>
<p>Emission of bytecode is handled by the following macros:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>add a specified opcode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_NOLINE(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>like <code class="docutils literal notranslate"><span class="pre">ADDOP</span></code> without a line number; used for artificial opcodes without
no corresponding token in the source code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_IN_SCOPE(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>like <code class="docutils literal notranslate"><span class="pre">ADDOP</span></code>, but also exits current scope; used for adding return value
opcodes in lambdas and closures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_I(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">Py_ssize_t)</span></code></dt><dd><p>add an opcode that takes an integer argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_O(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">PyObject</span> <span class="pre">*,</span> <span class="pre">TYPE)</span></code></dt><dd><p>add an opcode with the proper argument based on the position of the
specified PyObject in PyObject sequence object, but with no handling of
mangled names; used for when you
need to do named lookups of objects such as globals, consts, or
parameters where name mangling is not possible and the scope of the
name is known; <em>TYPE</em> is the name of PyObject sequence
(<code class="docutils literal notranslate"><span class="pre">names</span></code> or <code class="docutils literal notranslate"><span class="pre">varnames</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_N(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">PyObject</span> <span class="pre">*,</span> <span class="pre">TYPE)</span></code></dt><dd><p>just like <code class="docutils literal notranslate"><span class="pre">ADDOP_O</span></code>, but steals a reference to PyObject</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_NAME(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">PyObject</span> <span class="pre">*,</span> <span class="pre">TYPE)</span></code></dt><dd><p>just like <code class="docutils literal notranslate"><span class="pre">ADDOP_O</span></code>, but name mangling is also handled; used for
attribute loading or importing based on name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_LOAD_CONST(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">PyObject</span> <span class="pre">*)</span></code></dt><dd><p>add the <cite>LOAD_CONST</cite> opcode with the proper argument based on the
position of the specified PyObject in the consts table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_LOAD_CONST_NEW(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">PyObject</span> <span class="pre">*)</span></code></dt><dd><p>just like <code class="docutils literal notranslate"><span class="pre">ADDOP_LOAD_CONST_NEW</span></code>, but steals a reference to PyObject</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_JUMP(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">basicblock</span> <span class="pre">*)</span></code></dt><dd><p>create a jump to a basic block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_JUMP_NOLINE(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">basicblock</span> <span class="pre">*)</span></code></dt><dd><p>like <code class="docutils literal notranslate"><span class="pre">ADDOP_JUMP</span></code> without a line number; used for artificial jumps
without no corresponding token in the source code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ADDOP_JUMP_COMPARE(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">cmpop_ty)</span></code></dt><dd><p>depending on the second argument, add an <code class="docutils literal notranslate"><span class="pre">ADDOP_I</span></code> with either an
<code class="docutils literal notranslate"><span class="pre">IS_OP</span></code>, <code class="docutils literal notranslate"><span class="pre">CONTAINS_OP</span></code>, or <code class="docutils literal notranslate"><span class="pre">COMPARE_OP</span></code> opcode.</p>
</dd>
</dl>
<p>Several helper functions that will emit bytecode and are named
<code class="samp docutils literal notranslate"><span class="pre">compiler_</span><em><span class="pre">xx</span></em><span class="pre">()</span></code> where <em>xx</em> is what the function helps with (<code class="docutils literal notranslate"><span class="pre">list</span></code>,
<code class="docutils literal notranslate"><span class="pre">boolop</span></code>, etc.).  A rather useful one is <code class="docutils literal notranslate"><span class="pre">compiler_nameop()</span></code>.
This function looks up the scope of a variable and, based on the
expression context, emits the proper opcode to load, store, or delete
the variable.</p>
<p>As for handling the line number on which a statement is defined, this is
handled by <code class="docutils literal notranslate"><span class="pre">compiler_visit_stmt()</span></code> and thus is not a worry.</p>
<p>In addition to emitting bytecode based on the AST node, handling the
creation of basic blocks must be done.  Below are the macros and
functions used for managing basic blocks:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NEXT_BLOCK(struct</span> <span class="pre">compiler</span> <span class="pre">*)</span></code></dt><dd><p>create an implicit jump from the current block
to the new block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compiler_new_block(struct</span> <span class="pre">compiler</span> <span class="pre">*)</span></code></dt><dd><p>create a block but don’t use it (used for generating jumps)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compiler_use_next_block(struct</span> <span class="pre">compiler</span> <span class="pre">*,</span> <span class="pre">basicblock</span> <span class="pre">*block)</span></code></dt><dd><p>set a previously created block as a current block</p>
</dd>
</dl>
<p>Once the CFG is created, it must be flattened and then final emission of
bytecode occurs.  Flattening is handled using a post-order depth-first
search.  Once flattened, jump offsets are backpatched based on the
flattening and then a <code class="docutils literal notranslate"><span class="pre">PyCodeObject</span></code> is created.  All of this is
handled by calling <code class="docutils literal notranslate"><span class="pre">assemble()</span></code>.</p>
</section>
<section id="introducing-new-bytecode">
<h2>Introducing New Bytecode<a class="headerlink" href="#introducing-new-bytecode" title="永久链接至标题">¶</a></h2>
<p>Sometimes a new feature requires a new opcode.  But adding new bytecode is
not as simple as just suddenly introducing new bytecode in the AST -&gt;
bytecode step of the compiler.  Several pieces of code throughout Python depend
on having correct information about what bytecode exists.</p>
<p>First, you must choose a name and a unique identifier number.  The official
list of bytecode can be found in <code class="file docutils literal notranslate"><span class="pre">Lib/opcode.py</span></code>.  If the opcode is to
take an argument, it must be given a unique number greater than that assigned to
<code class="docutils literal notranslate"><span class="pre">HAVE_ARGUMENT</span></code> (as found in <code class="file docutils literal notranslate"><span class="pre">Lib/opcode.py</span></code>).</p>
<p>Once the name/number pair has been chosen and entered in <code class="file docutils literal notranslate"><span class="pre">Lib/opcode.py</span></code>,
you must also enter it into <code class="file docutils literal notranslate"><span class="pre">Doc/library/dis.rst</span></code>, and regenerate
<code class="file docutils literal notranslate"><span class="pre">Include/opcode.h</span></code> and <code class="file docutils literal notranslate"><span class="pre">Python/opcode_targets.h</span></code> by running
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-opcode</span> <span class="pre">regen-opcode-targets</span></code>.</p>
<p>With a new bytecode you must also change what is called the magic number for
.pyc files.  The variable <code class="docutils literal notranslate"><span class="pre">MAGIC_NUMBER</span></code> in
<code class="file docutils literal notranslate"><span class="pre">Lib/importlib/_bootstrap_external.py</span></code> contains the number.
Changing this number will lead to all .pyc files with the old <code class="docutils literal notranslate"><span class="pre">MAGIC_NUMBER</span></code>
to be recompiled by the interpreter on import.  Whenever <code class="docutils literal notranslate"><span class="pre">MAGIC_NUMBER</span></code> is
changed, the ranges in the <code class="docutils literal notranslate"><span class="pre">magic_values</span></code> array in <code class="file docutils literal notranslate"><span class="pre">PC/launcher.c</span></code>
must also be updated.  Changes to <code class="file docutils literal notranslate"><span class="pre">Lib/importlib/_bootstrap_external.py</span></code>
will take effect only after running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-importlib</span></code>. Running this
command before adding the new bytecode target to <code class="file docutils literal notranslate"><span class="pre">Python/ceval.c</span></code> will
result in an error. You should only run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-importlib</span></code> after the new
bytecode target has been added.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>On Windows, running the <code class="docutils literal notranslate"><span class="pre">./build.bat</span></code> script will automatically
regenerate the required files without requiring additional arguments.</p>
</div>
<p>Finally, you need to introduce the use of the new bytecode.  Altering
<code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code> and <code class="file docutils literal notranslate"><span class="pre">Python/ceval.c</span></code> will be the primary places
to change. You must add the case for a new opcode into the ‘switch’
statement in the <code class="docutils literal notranslate"><span class="pre">stack_effect()</span></code> function in <code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>.
If the new opcode has a jump target, you will need to update macros and
‘switch’ statements in <code class="file docutils literal notranslate"><span class="pre">Python/peephole.c</span></code>.  If it affects a control
flow or the block stack, you may have to update the <code class="docutils literal notranslate"><span class="pre">frame_setlineno()</span></code>
function in <code class="file docutils literal notranslate"><span class="pre">Objects/frameobject.c</span></code>.  <code class="file docutils literal notranslate"><span class="pre">Lib/dis.py</span></code> may need
an update if the new opcode interprets its argument in a special way (like
<code class="docutils literal notranslate"><span class="pre">FORMAT_VALUE</span></code> or <code class="docutils literal notranslate"><span class="pre">MAKE_FUNCTION</span></code>).</p>
<p>If you make a change here that can affect the output of bytecode that
is already in existence and you do not change the magic number constantly, make
sure to delete your old .py(c|o) files!  Even though you will end up changing
the magic number if you change the bytecode, while you are debugging your work
you will be changing the bytecode output without constantly bumping up the
magic number.  This means you end up with stale .pyc files that will not be
recreated.
Running <code class="docutils literal notranslate"><span class="pre">find</span> <span class="pre">.</span> <span class="pre">-name</span> <span class="pre">'*.py[co]'</span> <span class="pre">-exec</span> <span class="pre">rm</span> <span class="pre">-f</span> <span class="pre">'{}'</span> <span class="pre">+</span></code> should delete all .pyc
files you have, forcing new ones to be created and thus allow you test out your
new bytecode properly.  Run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-importlib</span></code> for updating the
bytecode of frozen importlib files.  You have to run <code class="docutils literal notranslate"><span class="pre">make</span></code> again after this
for recompiling generated C files.</p>
</section>
<section id="code-objects">
<h2>Code Objects<a class="headerlink" href="#code-objects" title="永久链接至标题">¶</a></h2>
<p>The result of <code class="docutils literal notranslate"><span class="pre">PyAST_CompileObject()</span></code> is a <code class="docutils literal notranslate"><span class="pre">PyCodeObject</span></code> which is defined in
<code class="file docutils literal notranslate"><span class="pre">Include/code.h</span></code>.  And with that you now have executable Python bytecode!</p>
<p>The code objects (byte code) are executed in <code class="file docutils literal notranslate"><span class="pre">Python/ceval.c</span></code>.  This file
will also need a new case statement for the new opcode in the big switch
statement in <code class="docutils literal notranslate"><span class="pre">_PyEval_EvalFrameDefault()</span></code>.</p>
</section>
<section id="important-files">
<h2>Important Files<a class="headerlink" href="#important-files" title="永久链接至标题">¶</a></h2>
<ul>
<li><p>Parser/</p>
<blockquote>
<div><dl class="simple">
<dt>Python.asdl</dt><dd><p>ASDL syntax file</p>
</dd>
<dt>asdl.py</dt><dd><p>Parser for ASDL definition files. Reads in an ASDL description
and parses it into an AST that describes it.</p>
</dd>
<dt>asdl_c.py</dt><dd><p>“Generate C code from an ASDL description.”  Generates
<code class="file docutils literal notranslate"><span class="pre">Python/Python-ast.c</span></code> and <code class="file docutils literal notranslate"><span class="pre">Include/Internal/pycore_ast.h</span></code>.</p>
</dd>
<dt>parser.c</dt><dd><p>The new PEG parser introduced in Python 3.9.
Generated by <code class="file docutils literal notranslate"><span class="pre">Tools/peg_generator/pegen/c_generator.py</span></code>
from the grammar <code class="file docutils literal notranslate"><span class="pre">Grammar/python.gram</span></code>.  Creates the AST from
source code.  Rule functions for their corresponding production rules
are found here.</p>
</dd>
<dt>peg_api.c</dt><dd><p>Contains high-level functions which are used by the interpreter to
create an AST from source code .</p>
</dd>
<dt>pegen.c</dt><dd><p>Contains helper functions which are used by functions in
<code class="file docutils literal notranslate"><span class="pre">Parser/parser.c</span></code> to construct the AST.  Also contains helper
functions which help raise better error messages when parsing source
code.</p>
</dd>
<dt>pegen.h</dt><dd><p>Header file for the corresponding <code class="file docutils literal notranslate"><span class="pre">Parser/pegen.c</span></code>. Also contains
definitions of the <code class="docutils literal notranslate"><span class="pre">Parser</span></code> and <code class="docutils literal notranslate"><span class="pre">Token</span></code> structs.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>Python/</p>
<blockquote>
<div><dl class="simple">
<dt>Python-ast.c</dt><dd><p>Creates C structs corresponding to the ASDL types.  Also
contains code for marshalling AST nodes (core ASDL types have
marshalling code in <code class="file docutils literal notranslate"><span class="pre">asdl.c</span></code>).  “File automatically generated by
<code class="file docutils literal notranslate"><span class="pre">Parser/asdl_c.py</span></code>”.  This file must be committed separately
after every grammar change is committed since the <code class="docutils literal notranslate"><span class="pre">__version__</span></code>
value is set to the latest grammar change revision number.</p>
</dd>
<dt>asdl.c</dt><dd><p>Contains code to handle the ASDL sequence type.  Also has code
to handle marshalling the core ASDL types, such as number and
identifier.  Used by <code class="file docutils literal notranslate"><span class="pre">Python-ast.c</span></code> for marshalling AST nodes.</p>
</dd>
<dt>ast.c</dt><dd><p>Used for validating the AST.</p>
</dd>
<dt>ast_opt.c</dt><dd><p>Optimizes the AST.</p>
</dd>
<dt>ast_unparse.c</dt><dd><p>Converts the AST expression node back into a string
(for string annotations).</p>
</dd>
<dt>ceval.c</dt><dd><p>Executes byte code (aka, eval loop).</p>
</dd>
<dt>compile.c</dt><dd><p>Emits bytecode based on the AST.</p>
</dd>
<dt>symtable.c</dt><dd><p>Generates a symbol table from AST.</p>
</dd>
<dt>peephole.c</dt><dd><p>Optimizes the bytecode.</p>
</dd>
<dt>pyarena.c</dt><dd><p>Implementation of the arena memory manager.</p>
</dd>
<dt>wordcode_helpers.h</dt><dd><p>Helpers for generating bytecode.</p>
</dd>
<dt>opcode_targets.h</dt><dd><p>One of the files that must be modified if <code class="file docutils literal notranslate"><span class="pre">Lib/opcode.py</span></code> is.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>Include/</p>
<blockquote>
<div><dl class="simple">
<dt>code.h</dt><dd><p>Header file for <code class="file docutils literal notranslate"><span class="pre">Objects/codeobject.c</span></code>; contains definition of
<code class="docutils literal notranslate"><span class="pre">PyCodeObject</span></code>.</p>
</dd>
<dt>opcode.h</dt><dd><p>One of the files that must be modified if <code class="file docutils literal notranslate"><span class="pre">Lib/opcode.py</span></code> is.</p>
</dd>
</dl>
<ul>
<li><p>Internal/</p>
<blockquote>
<div><dl class="simple">
<dt>pycore_ast.h</dt><dd><p>Contains the actual definitions of the C structs as generated by
<code class="file docutils literal notranslate"><span class="pre">Python/Python-ast.c</span></code>.
“Automatically generated by <code class="file docutils literal notranslate"><span class="pre">Parser/asdl_c.py</span></code>”.</p>
</dd>
<dt>pycore_asdl.h</dt><dd><p>Header for the corresponding <code class="file docutils literal notranslate"><span class="pre">Python/ast.c</span></code></p>
</dd>
<dt>pycore_ast.h</dt><dd><p>Declares <code class="docutils literal notranslate"><span class="pre">_PyAST_Validate()</span></code> external (from <code class="file docutils literal notranslate"><span class="pre">Python/ast.c</span></code>).</p>
</dd>
<dt>pycore_symtable.h</dt><dd><p>Header for <code class="file docutils literal notranslate"><span class="pre">Python/symtable.c</span></code>.  <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">symtable</span></code> and
<code class="docutils literal notranslate"><span class="pre">PySTEntryObject</span></code> are defined here.</p>
</dd>
<dt>pycore_parser.h</dt><dd><p>Header for the corresponding <code class="file docutils literal notranslate"><span class="pre">Parser/peg_api.c</span></code>.</p>
</dd>
<dt>pycore_pyarena.h</dt><dd><p>Header file for the corresponding <code class="file docutils literal notranslate"><span class="pre">Python/pyarena.c</span></code>.</p>
</dd>
</dl>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Objects/</p>
<blockquote>
<div><dl class="simple">
<dt>codeobject.c</dt><dd><p>Contains PyCodeObject-related code (originally in
<code class="file docutils literal notranslate"><span class="pre">Python/compile.c</span></code>).</p>
</dd>
<dt>frameobject.c</dt><dd><p>Contains the <code class="docutils literal notranslate"><span class="pre">frame_setlineno()</span></code> function which should determine
whether it is allowed to make a jump between two points in a bytecode.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>Lib/</p>
<blockquote>
<div><dl class="simple">
<dt>opcode.py</dt><dd><p>Master list of bytecode; if this file is modified you must modify
several other files accordingly (see “<a class="reference internal" href="#introducing-new-bytecode">Introducing New Bytecode</a>”)</p>
</dd>
<dt>importlib/_bootstrap_external.py</dt><dd><p>Home of the magic number (named <code class="docutils literal notranslate"><span class="pre">MAGIC_NUMBER</span></code>) for bytecode
versioning.</p>
</dd>
</dl>
</div></blockquote>
</li>
</ul>
</section>
<section id="known-compiler-related-experiments">
<h2>Known Compiler-related Experiments<a class="headerlink" href="#known-compiler-related-experiments" title="永久链接至标题">¶</a></h2>
<p>This section lists known experiments involving the compiler (including
bytecode).</p>
<p>Skip Montanaro presented a paper at a Python workshop on a peephole optimizer
<a class="footnote-reference brackets" href="#skip-peephole" id="id2">1</a>.</p>
<p>Michael Hudson has a non-active SourceForge project named Bytecodehacks
<a class="footnote-reference brackets" href="#bytecodehacks" id="id3">2</a> that provides functionality for playing with bytecode
directly.</p>
<p>An opcode to combine the functionality of <code class="docutils literal notranslate"><span class="pre">LOAD_ATTR</span></code>/<code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION</span></code> was
created named <code class="docutils literal notranslate"><span class="pre">CALL_ATTR</span></code> <a class="footnote-reference brackets" href="#call-attr" id="id4">3</a>.  Currently only works for classic
classes and for new-style classes rough benchmarking showed an actual slowdown
thanks to having to support both classic and new-style classes.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="永久链接至标题">¶</a></h2>
<dl class="citation">
<dt class="label" id="wang97"><span class="brackets"><a class="fn-backref" href="#id1">Wang97</a></span></dt>
<dd><p>Daniel C. Wang, Andrew W. Appel, Jeff L. Korn, and Chris
S. Serra.  <a class="reference external" href="https://www.cs.princeton.edu/research/techreps/TR-554-97">The Zephyr Abstract Syntax Description Language.</a>
In Proceedings of the Conference on Domain-Specific Languages, pp.
213–227, 1997.</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="skip-peephole"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Skip Montanaro’s Peephole Optimizer Paper
(<a class="reference external" href="https://drive.google.com/open?id=0B2InO7qBBGRXQXlDM3FVdWZxQWc">https://drive.google.com/open?id=0B2InO7qBBGRXQXlDM3FVdWZxQWc</a>)</p>
</dd>
<dt class="label" id="bytecodehacks"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Bytecodehacks Project
(<a class="reference external" href="http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html">http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html</a>)</p>
</dd>
<dt class="label" id="call-attr"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>CALL_ATTR opcode
(<a class="reference external" href="https://bugs.python.org/issue709744">https://bugs.python.org/issue709744</a>)</p>
</dd>
</dl>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="garbage_collector.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Design of CPython’s Garbage Collector</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="parser.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Guide to CPython’s Parser</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2011-2021, Python Software Foundation |
            最后更新于 11月 22, 2021. |
          Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
          <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
            | <a class="muted-link" href="_sources/compiler.rst.txt"
               rel="nofollow">
              显示源代码
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Design of CPython’s Compiler</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#parsing">Parsing</a></li>
<li><a class="reference internal" href="#abstract-syntax-trees-ast">Abstract Syntax Trees (AST)</a></li>
<li><a class="reference internal" href="#memory-management">Memory Management</a></li>
<li><a class="reference internal" href="#source-code-to-ast">Source Code to AST</a></li>
<li><a class="reference internal" href="#control-flow-graphs">Control Flow Graphs</a></li>
<li><a class="reference internal" href="#ast-to-cfg-to-bytecode">AST to CFG to Bytecode</a></li>
<li><a class="reference internal" href="#introducing-new-bytecode">Introducing New Bytecode</a></li>
<li><a class="reference internal" href="#code-objects">Code Objects</a></li>
<li><a class="reference internal" href="#important-files">Important Files</a></li>
<li><a class="reference internal" href="#known-compiler-related-experiments">Known Compiler-related Experiments</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    </body>
</html>