# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2021, Python Software Foundation
# This file is distributed under the same license as the Python Developer's
# Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Developer's Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-22 09:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../parser.rst:4
msgid "Guide to CPython's Parser"
msgstr ""

#: ../../parser.rst
msgid "Author"
msgstr ""

#: ../../parser.rst:6
msgid "Pablo Galindo Salgado"
msgstr ""

#: ../../parser.rst:11
msgid "Abstract"
msgstr ""

#: ../../parser.rst:13
msgid ""
"The Parser in CPython is currently a `PEG (Parser Expression Grammar) "
"<https://en.wikipedia.org/wiki/Parsing_expression_grammar>`_ parser.  The"
" first version of the parser used to be an `LL(1) "
"<https://en.wikipedia.org/wiki/LL_parser>`_ based parser that was one of "
"the oldest parts of CPython implemented before it was replaced by "
":pep:`617`. In particular, both the current parser and the old LL(1) "
"parser are the output of a `parser generator "
"<https://en.wikipedia.org/wiki/Compiler-compiler>`_. This means that the "
"way the parser is written is by feeding a description of the Grammar of "
"the Python language to a special program (the parser generator) which "
"outputs the parser. The way the Python language is changed is therefore "
"by modifying the grammar file and developers rarely need to interact with"
" the parser generator itself other than use it to generate the parser."
msgstr ""

#: ../../parser.rst:27
msgid "How PEG Parsers Work"
msgstr ""

#: ../../parser.rst:31
msgid ""
"A PEG (Parsing Expression Grammar) grammar (like the current one) differs"
" from a context-free grammar in that the way it is written more closely "
"reflects how the parser will operate when parsing it. The fundamental "
"technical difference is that the choice operator is ordered. This means "
"that when writing::"
msgstr ""

#: ../../parser.rst:38
msgid ""
"a context-free-grammar parser (like an LL(1) parser) will generate "
"constructions that given an input string will *deduce* which alternative "
"(``A``, ``B`` or ``C``) must be expanded, while a PEG parser will check "
"if the first alternative succeeds and only if it fails, will it continue "
"with the second or the third one in the order in which they are written. "
"This makes the choice operator not commutative."
msgstr ""

#: ../../parser.rst:44
msgid ""
"Unlike LL(1) parsers, PEG-based parsers cannot be ambiguous: if a string "
"parses, it has exactly one valid parse tree. This means that a PEG-based "
"parser cannot suffer from the ambiguity problems that can arise with "
"LL(1) parsers and with context-free grammars in general."
msgstr ""

#: ../../parser.rst:49
msgid ""
"PEG parsers are usually constructed as a recursive descent parser in "
"which every rule in the grammar corresponds to a function in the program "
"implementing the parser and the parsing expression (the \"expansion\" or "
"\"definition\" of the rule) represents the \"code\" in said function. "
"Each parsing function conceptually takes an input string as its argument,"
" and yields one of the following results:"
msgstr ""

#: ../../parser.rst:55
msgid ""
"A \"success\" result. This result indicates that the expression can be "
"parsed by that rule and the function may optionally move forward or "
"consume one or more characters of the input string supplied to it."
msgstr ""

#: ../../parser.rst:58
msgid "A \"failure\" result, in which case no input is consumed."
msgstr ""

#: ../../parser.rst:60
msgid ""
"Notice that \"failure\" results do not imply that the program is "
"incorrect, nor do they necessarily mean that the parsing has failed. "
"Since the choice operator is ordered, a failure very often merely "
"indicates \"try the following option\".  A direct implementation of a PEG"
" parser as a recursive descent parser will present exponential time "
"performance in the worst case, because PEG parsers have infinite "
"lookahead (this means that they can consider an arbitrary number of "
"tokens before deciding for a rule).  Usually, PEG parsers avoid this "
"exponential time complexity with a technique called \"packrat parsing\" "
"[1]_ which not only loads the entire program in memory before parsing it "
"but also allows the parser to backtrack arbitrarily. This is made "
"efficient by memoizing the rules already matched for each position. The "
"cost of the memoization cache is that the parser will naturally use more "
"memory than a simple LL(1) parser, which normally are table-based."
msgstr ""

#: ../../parser.rst:76
msgid "Key ideas"
msgstr ""

#: ../../parser.rst:79
msgid ""
"Don't try to reason about a PEG grammar in the same way you would to with"
" an EBNF or context free grammar. PEG is optimized to describe **how** "
"input strings will be parsed, while context-free grammars are optimized "
"to generate strings of the language they describe (in EBNF, to know if a "
"given string is in the language, you need to do work to find out as it is"
" not immediately obvious from the grammar)."
msgstr ""

#: ../../parser.rst:85
msgid "Alternatives are ordered ( ``A | B`` is not the same as ``B | A`` )."
msgstr ""

#: ../../parser.rst:86
msgid ""
"If a rule returns a failure, it doesn't mean that the parsing has failed,"
" it just means \"try something else\"."
msgstr ""

#: ../../parser.rst:88
msgid ""
"By default PEG parsers run in exponential time, which can be optimized to"
" linear by using memoization."
msgstr ""

#: ../../parser.rst:90
msgid ""
"If parsing fails completely (no rule succeeds in parsing all the input "
"text), the PEG parser doesn't have a concept of \"where the "
":exc:`SyntaxError` is\"."
msgstr ""

#: ../../parser.rst:95
msgid "Consequences or the ordered choice operator"
msgstr ""

#: ../../parser.rst:99
msgid ""
"Although PEG may look like EBNF, its meaning is quite different. The fact"
" that in PEG parsers alternatives are ordered (which is at the core of "
"how PEG parsers work) has deep consequences, other than removing "
"ambiguity."
msgstr ""

#: ../../parser.rst:103
msgid ""
"If a rule has two alternatives and the first of them succeeds, the second"
" one is **not** attempted even if the caller rule fails to parse the rest"
" of the input. Thus the parser is said to be \"eager\". To illustrate "
"this, consider the following two rules (in these examples, a token is an "
"individual character): ::"
msgstr ""

#: ../../parser.rst:111
msgid ""
"In a regular EBNF grammar, both rules specify the language ``{aa, aaa}`` "
"but in PEG, one of these two rules accepts the string ``aaa`` but not the"
" string ``aa``. The other does the opposite -- it accepts the string "
"``aa`` but not the string ``aaa``. The rule ``('a'|'aa')'a'`` does not "
"accept ``aaa`` because ``'a'|'aa'`` consumes the first ``a``, letting the"
" final ``a`` in the rule consume the second, and leaving out the third "
"``a``. As the rule has succeeded, no attempt is ever made to go back and "
"let ``'a'|'aa'`` try the second alternative. The expression "
"``('aa'|'a')'a'`` does not accept ``aa`` because ``'aa'|'a'`` accepts all"
" of ``aa``, leaving nothing for the final ``a``. Again, the second "
"alternative of ``'aa'|'a'`` is not tried."
msgstr ""

#: ../../parser.rst:125
msgid ""
"The effects of ordered choice, such as the ones illustrated above, may be"
" hidden by many levels of rules."
msgstr ""

#: ../../parser.rst:127
msgid ""
"For this reason, writing rules where an alternative is contained in the "
"next one is in almost all cases a mistake, for example: ::"
msgstr ""

#: ../../parser.rst:134
msgid ""
"In this example, the second alternative will never be tried because the "
"first one will succeed first (even if the input string has an ``'else' "
"block`` that follows). To correctly write this rule you can simply alter "
"the order: ::"
msgstr ""

#: ../../parser.rst:142
msgid ""
"In this case, if the input string doesn't have an ``'else' block``, the "
"first alternative will fail and the second will be attempted without said"
" part."
msgstr ""

#: ../../parser.rst:146
msgid "Syntax"
msgstr ""

#: ../../parser.rst:148
msgid "The grammar consists of a sequence of rules of the form: ::"
msgstr ""

#: ../../parser.rst:152
msgid ""
"Optionally, a type can be included right after the rule name, which "
"specifies the return type of the C or Python function corresponding to "
"the rule: ::"
msgstr ""

#: ../../parser.rst:158
msgid ""
"If the return type is omitted, then a ``void *`` is returned in C and an "
"``Any`` in Python."
msgstr ""

#: ../../parser.rst:162
msgid "Grammar Expressions"
msgstr ""

#: ../../parser.rst:165
msgid "``# comment``"
msgstr ""

#: ../../parser.rst:167
msgid "Python-style comments."
msgstr ""

#: ../../parser.rst:170
msgid "``e1 e2``"
msgstr ""

#: ../../parser.rst:172
msgid "Match ``e1``, then match ``e2``."
msgstr ""

#: ../../parser.rst:179
msgid "``e1 | e2``"
msgstr ""

#: ../../parser.rst:181
msgid "Match ``e1`` or ``e2``."
msgstr ""

#: ../../parser.rst:183
msgid ""
"The first alternative can also appear on the line after the rule name for"
" formatting purposes. In that case, a \\| must be used before the first "
"alternative, like so:"
msgstr ""

#: ../../parser.rst:194
msgid "``( e )``"
msgstr ""

#: ../../parser.rst:196
msgid "Match ``e``."
msgstr ""

#: ../../parser.rst:202
msgid ""
"A slightly more complex and useful example includes using the grouping "
"operator together with the repeat operators:"
msgstr ""

#: ../../parser.rst:210
msgid "``[ e ] or e?``"
msgstr ""

#: ../../parser.rst:212
msgid "Optionally match ``e``."
msgstr ""

#: ../../parser.rst:218
msgid "A more useful example includes defining that a trailing comma is optional:"
msgstr ""

#: ../../parser.rst:226
msgid "``e*``"
msgstr ""

#: ../../parser.rst:228
msgid "Match zero or more occurrences of ``e``."
msgstr ""

#: ../../parser.rst:235
msgid "``e+``"
msgstr ""

#: ../../parser.rst:237
msgid "Match one or more occurrences of ``e``."
msgstr ""

#: ../../parser.rst:244
msgid "``s.e+``"
msgstr ""

#: ../../parser.rst:246
msgid ""
"Match one or more occurrences of ``e``, separated by ``s``. The generated"
" parse tree does not include the separator. This is otherwise identical "
"to ``(e (s e)*)``."
msgstr ""

#: ../../parser.rst:255
msgid "``&e``"
msgstr ""

#: ../../parser.rst:259
msgid "Succeed if ``e`` can be parsed, without consuming any input."
msgstr ""

#: ../../parser.rst:262
msgid "``!e``"
msgstr ""

#: ../../parser.rst:266
msgid "Fail if ``e`` can be parsed, without consuming any input."
msgstr ""

#: ../../parser.rst:268
msgid ""
"An example taken from the Python grammar specifies that a primary "
"consists of an atom, which is not followed by a ``.`` or a ``(`` or a "
"``[``:"
msgstr ""

#: ../../parser.rst:277
msgid "``~``"
msgstr ""

#: ../../parser.rst:279
msgid ""
"Commit to the current alternative, even if it fails to parse (this is "
"called the \"cut\")."
msgstr ""

#: ../../parser.rst:286
msgid ""
"In this example, if a left parenthesis is parsed, then the other "
"alternative won’t be considered, even if some_rule or ``)`` fail to be "
"parsed."
msgstr ""

#: ../../parser.rst:291
msgid "Left recursion"
msgstr ""

#: ../../parser.rst:293
msgid ""
"PEG parsers normally do not support left recursion but CPython's parser "
"generator implements a technique similar to the one described in Medeiros"
" et al. [2]_ but using the memoization cache instead of static variables."
" This approach is closer to the one described in Warth et al. [3]_. This "
"allows us to write not only simple left-recursive rules but also more "
"complicated rules that involve indirect left-recursion like::"
msgstr ""

#: ../../parser.rst:304
msgid "and \"hidden left-recursion\" like::"
msgstr ""

#: ../../parser.rst:309
msgid "Variables in the Grammar"
msgstr ""

#: ../../parser.rst:311
msgid ""
"A sub-expression can be named by preceding it with an identifier and an "
"``=`` sign. The name can then be used in the action (see below), like "
"this: ::"
msgstr ""

#: ../../parser.rst:317
msgid "Grammar actions"
msgstr ""

#: ../../parser.rst:321
msgid ""
"To avoid the intermediate steps that obscure the relationship between the"
" grammar and the AST generation the PEG parser allows directly generating"
" AST nodes for a rule via grammar actions. Grammar actions are language-"
"specific expressions that are evaluated when a grammar rule is "
"successfully parsed. These expressions can be written in Python or C "
"depending on the desired output of the parser generator. This means that "
"if one would want to generate a parser in Python and another in C, two "
"grammar files should be written, each one with a different set of "
"actions, keeping everything else apart from said actions identical in "
"both files. As an example of a grammar with Python actions, the piece of "
"the parser generator that parses grammar files is bootstrapped from a "
"meta-grammar file with Python actions that generate the grammar tree as a"
" result of the parsing."
msgstr ""

#: ../../parser.rst:334
msgid ""
"In the specific case of the PEG grammar for Python, having actions allows"
" directly describing how the AST is composed in the grammar itself, "
"making it more clear and maintainable. This AST generation process is "
"supported by the use of some helper functions that factor out common AST "
"object manipulations and some other required operations that are not "
"directly related to the grammar."
msgstr ""

#: ../../parser.rst:340
msgid ""
"To indicate these actions each alternative can be followed by the action "
"code inside curly-braces, which specifies the return value of the "
"alternative::"
msgstr ""

#: ../../parser.rst:347
msgid "If the action is omitted, a default action is generated:"
msgstr ""

#: ../../parser.rst:349
msgid "If there's a single name in the rule, it gets returned."
msgstr ""

#: ../../parser.rst:351
msgid ""
"If there is more than one name in the rule, a collection with all parsed "
"expressions gets returned (the type of the collection will be different "
"in C and Python)."
msgstr ""

#: ../../parser.rst:355
msgid ""
"This default behaviour is primarily made for very simple situations and "
"for debugging purposes."
msgstr ""

#: ../../parser.rst:360
msgid ""
"It's important that the actions don't mutate any AST nodes that are "
"passed into them via variables referring to other rules. The reason for "
"mutation being not allowed is that the AST nodes are cached by "
"memoization and could potentially be reused in a different context, where"
" the mutation would be invalid. If an action needs to change an AST node,"
" it should instead make a new copy of the node and change that."
msgstr ""

#: ../../parser.rst:367
msgid "The full meta-grammar for the grammars supported by the PEG generator is:"
msgstr ""

#: ../../parser.rst:458
msgid ""
"As an illustrative example this simple grammar file allows directly "
"generating a full parser that can parse simple arithmetic expressions and"
" that returns a valid C-based Python AST:"
msgstr ""

#: ../../parser.rst:485
msgid ""
"Here ``EXTRA`` is a macro that expands to ``start_lineno, "
"start_col_offset, end_lineno, end_col_offset, p->arena``, those being "
"variables automatically injected by the parser; ``p`` points to an object"
" that holds on to all state for the parser."
msgstr ""

#: ../../parser.rst:490
msgid "A similar grammar written to target Python AST objects:"
msgstr ""

#: ../../parser.rst:517
msgid "Pegen"
msgstr ""

#: ../../parser.rst:519
msgid ""
"Pegen is the parser generator used in CPython to produce the final PEG "
"parser used by the interpreter. It is the program that can be used to "
"read the python grammar located in :file:`Grammar/Python.gram` and "
"produce the final C parser. It contains the following pieces:"
msgstr ""

#: ../../parser.rst:523
msgid ""
"A parser generator that can read a grammar file and produce a PEG parser "
"written in Python or C that can parse said grammar. The generator is "
"located at :file:`Tools/peg_generator/pegen`."
msgstr ""

#: ../../parser.rst:525
msgid ""
"A PEG meta-grammar that automatically generates a Python parser that is "
"used for the parser generator itself (this means that there are no "
"manually-written parsers). The meta-grammar is located at "
":file:`Tools/peg_generator/pegen/metagrammar.gram`."
msgstr ""

#: ../../parser.rst:528
msgid ""
"A generated parser (using the parser generator) that can directly produce"
" C and Python AST objects."
msgstr ""

#: ../../parser.rst:530
msgid ""
"The source code for Pegen lives at :file:`Tools/peg_generator/pegen` but "
"normally all typical commands to interact with the parser generator are "
"executed from the main makefile."
msgstr ""

#: ../../parser.rst:534
msgid "How to regenerate the parser"
msgstr ""

#: ../../parser.rst:536
msgid ""
"Once you have made the changes to the grammar files, to regenerate the "
"``C`` parser (the one used by the interpreter) just execute: ::"
msgstr ""

#: ../../parser.rst:541
msgid ""
"using the :file:`Makefile` in the main directory.  If you are on Windows "
"you can use the Visual Studio project files to regenerate the parser or "
"to execute: ::"
msgstr ""

#: ../../parser.rst:546
msgid "The generated parser file is located at :file:`Parser/parser.c`."
msgstr ""

#: ../../parser.rst:549
msgid "How to regenerate the meta-parser"
msgstr ""

#: ../../parser.rst:551
msgid ""
"The meta-grammar (the grammar that describes the grammar for the grammar "
"files themselves) is located at "
":file:`Tools/peg_generator/pegen/metagrammar.gram`. Although it is very "
"unlikely that you will ever need to modify it, if you make any "
"modifications to this file (in order to implement new Pegen features) you"
" will need to regenerate the meta-parser (the parser that parses the "
"grammar files). To do so just execute: ::"
msgstr ""

#: ../../parser.rst:559
msgid ""
"If you are on Windows you can use the Visual Studio project files to "
"regenerate the parser or to execute: ::"
msgstr ""

#: ../../parser.rst:566
msgid "Grammatical elements and rules"
msgstr ""

#: ../../parser.rst:568
msgid "Pegen has some special grammatical elements and rules:"
msgstr ""

#: ../../parser.rst:570
msgid "Strings with single quotes (') (e.g. ``'class'``) denote KEYWORDS."
msgstr ""

#: ../../parser.rst:571
msgid "Strings with double quotes (\") (e.g. ``\"match\"``) denote SOFT KEYWORDS."
msgstr ""

#: ../../parser.rst:572
msgid ""
"Upper case names (e.g. ``NAME``) denote tokens in the "
":file:`Grammar/Tokens` file."
msgstr ""

#: ../../parser.rst:573
msgid ""
"Rule names starting with `invalid_` are used for specialized syntax "
"errors."
msgstr ""

#: ../../parser.rst:575
msgid "These rules are NOT used in the first pass of the parser."
msgstr ""

#: ../../parser.rst:576
msgid ""
"Only if the first pass fails to parse, a second pass including the "
"invalid rules will be executed."
msgstr ""

#: ../../parser.rst:578
msgid ""
"If the parser fails in the second phase with a generic syntax error, the "
"location of the generic failure of the first pass will be used (this "
"avoids reporting incorrect locations due to the invalid rules)."
msgstr ""

#: ../../parser.rst:581
msgid ""
"The order of the alternatives involving invalid rules matter (like any "
"rule in PEG)."
msgstr ""

#: ../../parser.rst:585
msgid "Tokenization"
msgstr ""

#: ../../parser.rst:587
msgid ""
"It is common among PEG parser frameworks that the parser does both the "
"parsing and the tokenization, but this does not happen in Pegen. The "
"reason is that the Python language needs a custom tokenizer to handle "
"things like indentation boundaries, some special keywords like ``ASYNC`` "
"and ``AWAIT`` (for compatibility purposes), backtracking errors (such as "
"unclosed parenthesis), dealing with encoding, interactive mode and much "
"more. Some of these reasons are also there for historical purposes, and "
"some others are useful even today."
msgstr ""

#: ../../parser.rst:594
msgid ""
"The list of tokens (all uppercase names in the grammar) that you can use "
"can be found in the :file:`Grammar/Tokens` file. If you change this file "
"to add new tokens, make sure to regenerate the files by executing: ::"
msgstr ""

#: ../../parser.rst:599
msgid ""
"If you are on Windows you can use the Visual Studio project files to "
"regenerate the tokens or to execute: ::"
msgstr ""

#: ../../parser.rst:603
msgid ""
"How tokens are generated and the rules governing this is completely up to"
" the tokenizer (:file:`Parser/tokenizer.c`) and the parser just receives "
"tokens from it."
msgstr ""

#: ../../parser.rst:607
msgid "Memoization"
msgstr ""

#: ../../parser.rst:609
msgid ""
"As described previously, to avoid exponential time complexity in the "
"parser, memoization is used."
msgstr ""

#: ../../parser.rst:611
msgid ""
"The C parser used by Python is highly optimized and memoization can be "
"expensive both in memory and time. Although the memory cost is obvious "
"(the parser needs memory for storing previous results in the cache) the "
"execution time cost comes for continuously checking if the given rule has"
" a cache hit or not. In many situations, just parsing it again can be "
"faster. Pegen **disables memoization by default** except for rules with "
"the special marker `memo` after the rule name (and type, if present): ::"
msgstr ""

#: ../../parser.rst:620
msgid ""
"By selectively turning on memoization for a handful of rules, the parser "
"becomes faster and uses less memory."
msgstr ""

#: ../../parser.rst:623
msgid ""
"Left-recursive rules always use memoization, since the implementation of "
"left-recursion depends on it."
msgstr ""

#: ../../parser.rst:625
msgid ""
"To know if a new rule needs memoization or not, benchmarking is required "
"(comparing execution times and memory usage of some considerably big "
"files with and without memoization). There is a very simple "
"instrumentation API available in the generated C parse code that allows "
"to measure how much each rule uses memoization (check the "
":file:`Parser/pegen.c` file for more information) but it needs to be "
"manually activated."
msgstr ""

#: ../../parser.rst:633
msgid "Automatic variables"
msgstr ""

#: ../../parser.rst:635
msgid ""
"To make writing actions easier, Pegen injects some automatic variables in"
" the namespace available when writing actions. In the C parser, some of "
"these automatic variable names are:"
msgstr ""

#: ../../parser.rst:638
msgid "``p``: The parser structure."
msgstr ""

#: ../../parser.rst:639
msgid ""
"``EXTRA``: This is a macro that expands to ``(_start_lineno, "
"_start_col_offset, _end_lineno, _end_col_offset, p->arena)``, which is "
"normally used to create AST nodes as almost all constructors need these "
"attributes to be provided. All of the location variables are taken from "
"the location information of the current token."
msgstr ""

#: ../../parser.rst:644
msgid "Hard and Soft keywords"
msgstr ""

#: ../../parser.rst:647
msgid ""
"In the grammar files, keywords are defined using **single quotes** (e.g. "
"`'class'`) while soft keywords are defined using **double quotes** (e.g. "
"`\"match\"`)."
msgstr ""

#: ../../parser.rst:650
msgid ""
"There are two kinds of keywords allowed in pegen grammars: *hard* and "
"*soft* keywords. The difference between hard and soft keywords is that "
"hard keywords are always reserved words, even in positions where they "
"make no sense (e.g. ``x = class + 1``), while soft keywords only get a "
"special meaning in context. Trying to use a hard keyword as a variable "
"will always fail:"
msgstr ""

#: ../../parser.rst:669
msgid ""
"While soft keywords don't have this limitation if used in a context other"
" the one where they are defined as keywords:"
msgstr ""

#: ../../parser.rst:677
msgid ""
"The ``match`` and ``case`` keywords are soft keywords, so that they are "
"recognized as keywords at the beginning of a match statement or case "
"block respectively, but are allowed to be used in other places as "
"variable or argument names."
msgstr ""

#: ../../parser.rst:681
msgid "You can get a list of all keywords defined in the grammar from Python:"
msgstr ""

#: ../../parser.rst:692
msgid "as well as soft keywords:"
msgstr ""

#: ../../parser.rst:701
msgid ""
"Soft keywords can be a bit challenging to manage as they can be accepted "
"in places you don't intend to, given how the order alternatives behave in"
" PEG parsers (see :ref:`consequences of ordered choice section "
"<consequences-of-ordered-choice>` for some background on this). In "
"general, try to define them in places where there is not a lot of "
"alternatives."
msgstr ""

#: ../../parser.rst:708
msgid "Error handling"
msgstr ""

#: ../../parser.rst:710
msgid ""
"When a pegen-generated parser detects that an exception is raised, it "
"will **automatically stop parsing**, no matter what the current state of "
"the parser is and it will unwind the stack and report the exception. This"
" means that if a :ref:`rule action <peg-grammar-actions>` raises an "
"exception all parsing will stop at that exact point. This is done to "
"allow to correctly propagate any exception set by calling Python C-API "
"functions. This also includes :exc:`SyntaxError` exceptions and this is "
"the main mechanism the parser uses to report custom syntax error "
"messages."
msgstr ""

#: ../../parser.rst:720
msgid ""
"Tokenizer errors are normally reported by raising exceptions but some "
"special tokenizer errors such as unclosed parenthesis will be reported "
"only after the parser finishes without returning anything."
msgstr ""

#: ../../parser.rst:725
msgid "How Syntax errors are reported"
msgstr ""

#: ../../parser.rst:727
msgid ""
"As described previously in the :ref:`how PEG parsers work section <how-"
"peg-parsers-work>`, PEG parsers don't have a defined concept of where "
"errors happened in the grammar, because a rule failure doesn't imply a "
"parsing failure like in context free grammars. This means that some "
"heuristic has to be used to report generic errors unless something is "
"explicitly declared as an error in the grammar."
msgstr ""

#: ../../parser.rst:734
msgid ""
"To report generic syntax errors, pegen uses a common heuristic in PEG "
"parsers: the location of *generic* syntax errors is reported in the "
"furthest token that was attempted to be matched but failed. This is only "
"done if parsing has failed (the parser returns ``NULL`` in C or ``None`` "
"in Python) but no exception has been raised."
msgstr ""

#: ../../parser.rst:741
msgid ""
"Positive and negative lookaheads will try to match a token so they will "
"affect the location of generic syntax errors. Use them carefully at "
"boundaries between rules."
msgstr ""

#: ../../parser.rst:745
msgid ""
"As the Python grammar was primordially written as an LL(1) grammar, this "
"heuristic has an extremely high success rate, but some PEG features can "
"have small effects, such as :ref:`positive lookaheads <peg-positive-"
"lookahead>` and :ref:`negative lookaheads <peg-negative-lookahead>`."
msgstr ""

#: ../../parser.rst:750
msgid ""
"To generate more precise syntax errors, custom rules are used. This is a "
"common practice also in context free grammars: the parser will try to "
"accept some construct that is known to be incorrect just to report a "
"specific syntax error for that construct. In pegen grammars, these rules "
"start with the ``invalid_`` prefix. This is because trying to match these"
" rules normally has a performance impact on parsing (and can also affect "
"the 'correct' grammar itself in some tricky cases, depending on the "
"ordering of the rules) so the generated parser acts in two phases:"
msgstr ""

#: ../../parser.rst:758
msgid ""
"The first phase will try to parse the input stream without taking into "
"account rules that start with the ``invalid_`` prefix. If the parsing "
"succeeds it will return the generated AST and the second phase will not "
"be attempted."
msgstr ""

#: ../../parser.rst:762
msgid ""
"If the first phase failed, a second parsing attempt is done including the"
" rules that start with an ``invalid_`` prefix. By design this attempt "
"**cannot succeed** and is only executed to give to the invalid rules a "
"chance to detect specific situations where custom, more precise, syntax "
"errors can be raised. This also allows to trade a bit of performance for "
"precision reporting errors: given that we know that the input text is "
"invalid, there is no need to be fast because the interpreter is going to "
"stop anyway."
msgstr ""

#: ../../parser.rst:770
msgid "When defining invalid rules:"
msgstr ""

#: ../../parser.rst:772
msgid ""
"Make sure all custom invalid rules raise :exc:`SyntaxError` exceptions "
"(or a subclass of it)."
msgstr ""

#: ../../parser.rst:773
msgid ""
"Make sure **all** invalid rules start with the ``invalid_`` prefix to not"
" impact performance of parsing correct Python code."
msgstr ""

#: ../../parser.rst:775
msgid ""
"Make sure the parser doesn't behave differently for regular rules when "
"you introduce invalid rules (see the :ref:`how PEG parsers work section "
"<how-peg-parsers-work>` for more information)."
msgstr ""

#: ../../parser.rst:778
msgid ""
"You can find a collection of macros to raise specialized syntax errors in"
" the :file:`Parser/pegen.h` header file. These macros allow also to "
"report ranges for the custom errors that will be highlighted in the "
"tracebacks that will be displayed when the error is reported."
msgstr ""

#: ../../parser.rst:784
msgid ""
"A good way to test if an invalid rule will be triggered when you expect "
"is to test if introducing a syntax error **after** valid code triggers "
"the rule or not. For example: ::"
msgstr ""

#: ../../parser.rst:789
msgid ""
"Should trigger the syntax error in the ``$`` character. If your rule is "
"not correctly defined this won't happen. For example, if you try to "
"define a rule to match Python 2 style ``print`` statements to make a "
"better error message and you define it as: ::"
msgstr ""

#: ../../parser.rst:795
msgid ""
"This will **seem** to work because the parser will correctly parse "
"``print(something)`` because it is valid code and the second phase will "
"never execute but if you try to parse ``print(something) $ 3`` the first "
"pass of the parser will fail (because of the ``$``) and in the second "
"phase, the rule will match the ``print(something)`` as ``print`` followed"
" by the variable ``something`` between parentheses and the error will be "
"reported there instead of the ``$`` character."
msgstr ""

#: ../../parser.rst:802
msgid "Generating AST objects"
msgstr ""

#: ../../parser.rst:804
msgid ""
"The output of the C parser used by CPython that is generated by the "
":file:`Grammar/Python.gram` grammar file is a Python AST object (using C "
"structures). This means that the actions in the grammar file generate AST"
" objects when they succeed. Constructing these objects can be quite "
"cumbersome (see the :ref:`AST compiler section <compiler-ast-trees>` for "
"more information on how these objects are constructed and how they are "
"used by the compiler) so special helper functions are used. These "
"functions are declared in the :file:`Parser/pegen.h` header file and "
"defined in the :file:`Parser/action_helpers.c` file. These functions "
"allow you to join AST sequences, get specific elements from them or to do"
" extra processing on the generated tree."
msgstr ""

#: ../../parser.rst:816
msgid ""
"Actions must **never** be used to accept or reject rules. It may be "
"tempting in some situations to write a very generic rule and then check "
"the generated AST to decide if is valid or not but this will render the "
"`official grammar <https://docs.python.org/3/reference/grammar.html>`_ "
"partially incorrect (because actions are not included) and will make it "
"more difficult for other Python implementations to adapt the grammar to "
"their own needs."
msgstr ""

#: ../../parser.rst:823
msgid ""
"As a general rule, if an action spawns multiple lines or requires "
"something more complicated than a single expression of C code, is "
"normally better to create a custom helper in "
":file:`Parser/action_helpers.c` and expose it in the "
":file:`Parser/pegen.h` header file so it can be used from the grammar."
msgstr ""

#: ../../parser.rst:828
msgid ""
"If the parsing succeeds, the parser **must** return a **valid** AST "
"object."
msgstr ""

#: ../../parser.rst:831
msgid "Testing"
msgstr ""

#: ../../parser.rst:833
msgid "There are three files that contain tests for the grammar and the parser:"
msgstr ""

#: ../../parser.rst:835
msgid "`Lib/test/test_grammar.py`."
msgstr ""

#: ../../parser.rst:836
msgid "`Lib/test/test_syntax.py`."
msgstr ""

#: ../../parser.rst:837
msgid "`Lib/test/test_exceptions.py`."
msgstr ""

#: ../../parser.rst:839
msgid ""
"Check the contents of these files to know which is the best place to "
"place new tests depending on the nature of the new feature you are "
"adding."
msgstr ""

#: ../../parser.rst:842
msgid ""
"Tests for the parser generator itself can be found in the "
":file:`Lib/test/test_peg_generator` directory."
msgstr ""

#: ../../parser.rst:846
msgid "Debugging generated parsers"
msgstr ""

#: ../../parser.rst:849
msgid "Making experiments"
msgstr ""

#: ../../parser.rst:851
msgid ""
"As the generated C parser is the one used by Python, this means that if "
"something goes wrong when adding some new rules to the grammar you cannot"
" correctly compile and execute Python anymore. This makes it a bit "
"challenging to debug when something goes wrong, especially when making "
"experiments."
msgstr ""

#: ../../parser.rst:855
msgid ""
"For this reason it is a good idea to experiment first by generating a "
"Python parser. To do this, you can go to the :file:`Tools/peg_generator/`"
" directory on the CPython repository and manually call the parser "
"generator by executing:"
msgstr ""

#: ../../parser.rst:862
msgid ""
"This will generate a file called :file:`parse.py` in the same directory "
"that you can use to parse some input:"
msgstr ""

#: ../../parser.rst:868
msgid ""
"As the generated :file:`parse.py` file is just Python code, you can "
"modify it and add breakpoints to debug or better understand some complex "
"situations."
msgstr ""

#: ../../parser.rst:873
msgid "Verbose mode"
msgstr ""

#: ../../parser.rst:875
msgid ""
"When Python is compiled in debug mode (by adding ``--with-pydebug`` when "
"running the configure step in Linux or by adding ``-d`` when calling the "
":file:`PCbuild/python.bat` script in Windows), it is possible to activate"
" a **very** verbose mode in the generated parser. This is very useful to "
"debug the generated parser and to understand how it works, but it can be "
"a bit hard to understand at first."
msgstr ""

#: ../../parser.rst:882
msgid ""
"When activating verbose mode in the Python parser, it is better to not "
"use interactive mode as it can be much harder to understand, because "
"interactive mode involves some special steps compared to regular parsing."
msgstr ""

#: ../../parser.rst:885
msgid ""
"To activate verbose mode you can add the ``-d`` flag when executing "
"Python:"
msgstr ""

#: ../../parser.rst:891
msgid ""
"This will print **a lot** of output to ``stderr`` so is probably better "
"to dump it to a file for further analysis. The output consists of trace "
"lines with the following structure:"
msgstr ""

#: ../../parser.rst:894
msgid ""
"<indentation> ('>'|'-'|'+'|'!') <rule_name>[<token_location>]: "
"<alternative> ..."
msgstr ""

#: ../../parser.rst:896
msgid ""
"Every line is indented by a different amount (``<indentation>``) "
"depending on how deep the call stack is. The next character marks the "
"type of the trace:"
msgstr ""

#: ../../parser.rst:899
msgid "``>`` indicates that a rule is going to be attempted to be parsed."
msgstr ""

#: ../../parser.rst:900
msgid "``-`` indicates that a rule has failed to be parsed."
msgstr ""

#: ../../parser.rst:901
msgid "``+`` indicates that a rule has been parsed correctly."
msgstr ""

#: ../../parser.rst:902
msgid ""
"``!`` indicates that an exception or an error has been detected and the "
"parser is unwinding."
msgstr ""

#: ../../parser.rst:904
msgid ""
"The <token_location> part indicates the current index in the token array,"
" the <rule_name> part indicates what rule is being parsed and the "
"<alternative> part indicates what alternative within that rule is being "
"attempted."
msgstr ""

#: ../../parser.rst:910
msgid "References"
msgstr ""

#: ../../parser.rst:912
msgid "Ford, Bryan http://pdos.csail.mit.edu/~baford/packrat/thesis"
msgstr ""

#: ../../parser.rst:915
msgid "Medeiros et al. https://arxiv.org/pdf/1207.0443.pdf"
msgstr ""

#: ../../parser.rst:918
msgid "Warth et al. http://web.cs.ucla.edu/~todd/research/pepm08.pdf"
msgstr ""

